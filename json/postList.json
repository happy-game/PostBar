{
	"success": true,
	"data": [{
		"id": "6262718079f90d94a6a0d2f5",
		"author_id": "4f447c2f0a8abae26e01b27d",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h2>概述</h2>\n<p>Node.js 刚刚发布了 18.0.0 版本，内置了 <code>fetch</code>、<code>node:test</code> 等标准模块。</p>\n<p><strong>一句话点评：std lib 在标准化，user lib 在精细化。</strong></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/502951532\">EggJS 知乎专栏</a>，求点赞。</p>\n</blockquote>\n<hr>\n<h2>如何快速体验</h2>\n<p>推荐用 <a href=\"https://github.com/Schniz/fnm\">fnm</a>，<a href=\"https://github.com/jasongin/nvs\">nvs</a>，<a href=\"https://github.com/nvm-sh/nvm\">nvm</a> 等 Node.js 版本管理器。</p>\n<pre class=\"prettyprint language-bash\"><code>$ fnm install 18\nInstalling Node v18.0.0 (arm64)\n\n$ fnm use 18\nUsing Node v18.0.0\n\n$ node -v\nv18.0.0\n</code></pre><p>需要注意的是，该版本不是 LTS 版本，请勿在生产环境使用，需要等到 2022-10-25 才会成为 LTS 版本。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012135a1091b40ef807c8b6e3919bcce~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\" title=\"https://github.com/nodejs/Release\"></p>\n<h2>Looking to the future</h2>\n<blockquote>\n<p>The project is also continuing its ‘Next 10’ effort.  The goal of this effort is to reflect on what led to success in the first 10 years of Node.js and set the direction for success in the next 10.</p>\n</blockquote>\n<p>Node.js 官方启动了 <a href=\"https://github.com/nodejs/next-10\">next-10</a> 工作，并讨论出了<a href=\"https://github.com/nodejs/node/blob/master/doc/contributing/technical-priorities.md\">未来重要的几件事</a>：</p>\n<ul>\n<li>现代化的 HTTP</li>\n<li>友好的类型支持</li>\n<li>对初学者更友好的渐进式文档</li>\n<li>对 ECMAScript 规范的支持和及时跟进</li>\n<li>可观测性，包括 logging/metrics/tracing，以及 APM 等</li>\n<li>更好的多线程支持</li>\n<li>支持打包为单文件的分发方式</li>\n</ul>\n<p>譬如前面说的 Fetch 就和 Modern HTTP 的会议讨论有关，<a href=\"https://github.com/nodejs/next-10/blob/main/meetings/summit-jan-2022.md\">相关纪要</a>。</p>\n<blockquote>\n<p>6 月份的 OpenJS World 会议中将分享 ESM 和 Observability 进展，可以关注下相关动态。</p>\n</blockquote>\n<hr>\n<h2>Fetch API</h2>\n<p>前端同学应该都很熟悉<code>fetch()</code>这个 API，它提供了标准的网络请求能力，取代了远古的  XMLHttpRequest 。</p>\n<p>反观 Node.js 侧，官方提供的 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback\">http.request()</a>，太底层太基础了，用起来往往需要大量的封装。譬如 302 后自动跳转、文件上传、响应结果解析等等。</p>\n<p>因此在 Node.js 社区有非常多的上层请求库封装：</p>\n<ul>\n<li>曾经广受社区欢迎的 request 库去年<a href=\"https://github.com/request/request/issues/3142\">宣布停止维护</a>后，也引起了社区比较大的混乱。。</li>\n<li>我们 Egg 内置的是 <a href=\"https://www.npmjs.com/package/urllib\">urllib</a>，沉淀了阿里多年在网络请求上踩的坑，足够稳定，不过代码也有点久远了。</li>\n<li>更多参见 <a href=\"https://github.com/request/request/issues/3143\">Alternative libraries to request</a> 以及 <a href=\"https://zhuanlan.zhihu.com/p/415361629\">《天猪：那些你应该说再见的 npm 祖传老库》</a>。</li>\n</ul>\n<p><strong>去年 Node.js 官方推出了 <strong><a href=\"https://undici.nodejs.org/\"><strong>undici</strong></a></strong>，一个非常现代化的库，具备优越的性能，良好的扩展性，内置的 mock 等能力，集大成者。</strong></p>\n<blockquote>\n<p>undici 的命名也很有趣：A HTTP/1.1 client → 11 → Eleven → Undici，即意大利语的 11。</p>\n</blockquote>\n<p>从而 <strong>Node.js 终于内置了新的请求库</strong>，它遵循 <a href=\"https://fetch.spec.whatwg.org/\">Fetch 规范</a>，底层就是基于 undici 来实现的。</p>\n<pre class=\"prettyprint language-javascript\"><code>const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\nif (res.ok) {\n  const data = await res.json();\n  console.log(data);\n}\n</code></pre><p>就这么简单，比 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback\">http.request()</a> 那一坨 callback-style 代码简洁多了，平时写个脚本啥的，不用再引入额外的类库了。</p>\n<p>全局增加了 fetch, FormData, Headers, Request, Response 这几个 API，以及 Web Streams API。</p>\n<p>目前还处于默认开启的实验性特性阶段，文档在 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#fetch\">Globals</a> 章节，近乎没有，有需要直接看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">MDN 文档</a> 即可。</p>\n<p>可能是为了遵循规范， undici 的很多能力如 Mock，Proxy，Pool 等都没有提供出来。</p>\n<hr>\n<h2>Test Runner</h2>\n<p>单元测试很重要，很多新兴的编程语言都是会内置对应的能力，但前端这块一直都是由社区来实现，前端同学耳熟能详的 Test Runner 有 <a href=\"https://mochajs.org/\">Mocha</a>、<a href=\"https://jestjs.io/\">Jest</a>。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; mocha showcase\nimport assert from &#x27;assert&#x2F;strict&#x27;;\n\ndescribe(&#x27;test&#x2F;index.test.js&#x27;, () =&gt; {\n  it(&#x27;test1&#x27;, async () =&gt; {\n    const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\n    assert(res.ok);\n  });\n  \n  it.skip(&#x27;skip some test&#x27;, () =&gt; {});\n});\n</code></pre><p>终于，Node.js 在 18.x 里官方支持了 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/test.html\">Test 能力</a>：</p>\n<pre class=\"prettyprint language-javascript\"><code>import test from &#x27;node:test&#x27;;\nimport assert from &#x27;assert&#x2F;strict&#x27;;\n\n&#x2F;&#x2F; 等价于 describe()\ntest(&#x27;asynchronous passing test&#x27;, async () =&gt; {\n  const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\n  assert(res.ok);\n});\n\ntest(&#x27;multi level test&#x27;, async (t) =&gt; {\n  &#x2F;&#x2F; 等价于 it()\n  await t.test(&#x27;subtest 1&#x27;, (t) =&gt; {\n    assert.strictEqual(1, 1);\n  });\n\n  await t.test(&#x27;subtest 2&#x27;, (t) =&gt; {\n    assert.strictEqual(2, 2);\n  });\n});\n\n&#x2F;&#x2F; 等价于 describe.skip() &#x2F; it.skip()\ntest(&#x27;skip option&#x27;, { skip: true }, () =&gt; {});\n\n&#x2F;&#x2F; 等价于 describe.only() &#x2F; it.only()\ntest(&#x27;only option&#x27;, { only: true }, () =&gt; {});\n</code></pre><p>可以看到：</p>\n<ul>\n<li>语法其实差不多，会更简洁一点，就一个 <code>test()</code>，options 除了 skip 和 only 外，还支持 concurrency 并发。</li>\n<li>无需启动器，每一个文件都是一个可执行的 Node.js 代码。</li>\n<li>暂未支持 <code>before/after/beforeEach/afterEach</code> 能力，看 issue 描述会后续支持。</li>\n<li>暂未支持 Reporter，但日志输出为标准 <a href=\"https://testanything.org/\">TAP</a> 格式，所以应该很容易能复用现有的社区生态。</li>\n</ul>\n<p>类似覆盖率的演进过程，以前我们需要通过 nyc 对代码转译打桩，现在变为的 Node.js 内置覆盖率输出，nyc 变为 c8 这样的覆盖率报告生成工具。</p>\n<p>后续 mocha 等估计会变为类似的上层封装，提供批量执行 和 Reporter 等能力。</p>\n<hr>\n<h2>Build-time user-land snapshot</h2>\n<p>简单的说，可以把某个 js 直接编译成 v8 snapshot，从而可以极大的提速启动时间。</p>\n<p>目前这个版本，还只能通过 Node.js 源码来编译，且只能编译成 Node.js Runtime 的方式，即 Build-time。</p>\n<pre class=\"prettyprint language-bash\"><code># 把一段 markdown 渲染的逻辑，直接打包到 Node Runtime\n$ cd &#x2F;path&#x2F;to&#x2F;node&#x2F;source\n$ .&#x2F;configure --node-snapshot-main=marked.js\n$ make node\n\n# 执行编译好的 Node Runtime\n$ out&#x2F;Release&#x2F;node\n&gt; const html = globalThis.marked(&#x27;# this is title&#x27;);\n</code></pre><p>秋怡正在继续推进<a href=\"https://github.com/nodejs/node/issues/35711\">该能力</a>，未来可以无需编译 Node.js 源码：</p>\n<pre class=\"prettyprint language-bash\"><code>$ node --build-snapshot --snapshot-blob marked.blob marked.js \n$ node --snapshot-blob marked.blob\n</code></pre><p>PS：这个能力用在命令行 CLI 的独立打包好像也不错。<a href=\"https://github.com/nodejs/node/issues/42566\">https://github.com/nodejs/node/issues/42566</a></p>\n<hr>\n<h2>V8 引擎升级</h2>\n<p>内置的 V8 引擎升级到 10.1 版本，值得注意的特性：</p>\n<ul>\n<li>class fields 和 private class methods 的性能优化。</li>\n<li><a href=\"https://v8.dev/blog/v8-release-99#intl.locale-extensions\">Intl 规范</a> 的支持，在做日期的本地化，字符串处理的时候非常有用。</li>\n<li>数组支持 findLast() 和 findLastIndex() 等。</li>\n</ul>\n<p>秋怡也写了一篇文章 <a href=\"https://v8.dev/blog/faster-class-features\">Faster initialization of instances with new class features</a> 分享了背后的实现。</p>\n<p>PS：<a href=\"https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw\">ECMAScript 双月报告：装饰器提案进入 Stage 3</a> ，阿里的 Node 架构团队今年会推动 Decorator 方案在 V8 的落地实现，不过肯定赶不上了，只能 Node.js 20.x 见了。</p>\n<hr>\n<h2>ESM 的支持</h2>\n<p>虽然在 18.x 中没有新的内容，但在过去的几个月中一直在持续推动 ECMAScript模块实现：</p>\n<ul>\n<li>对 <a href=\"https://github.com/tc39/proposal-import-assertions\">JSON Import Assertions</a> 的支持。</li>\n<li>JSON 模块的正式支持。</li>\n<li>对 HTTPS 和 HTTP 导入的实验性支持。</li>\n<li><a href=\"https://github.com/nodejs/loaders\">Node.js 加载器团队</a>也在继续开发 ECMAScript 模块加载器实现。</li>\n</ul>\n<hr>\n<h2>工具链和编译器的升级</h2>\n<ul>\n<li>Linux 版是在 RHEL8 上构建的，要求 glibc 2.28 以上版本。</li>\n<li>macOS 要求 10.15 以上版本。</li>\n<li>Windows 很多旧版本也不支持了。</li>\n</ul>\n<p>PS：CentOS 7 官方不再维护了，它对应的 glibc 版本太低，所以升不了。。。</p>\n<ul>\n<li><a href=\"https://developer.aliyun.com/article/780803\">centos7和8不维护停止更新之后，服务器选择使用什么系统好？</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/42659\">doc: update minimum glibc requirements for Linux by richardlau</a></li>\n</ul>\n<hr>\n<h2>相关资料</h2>\n<ul>\n<li><a href=\"https://nodejs.org/en/blog/announcements/v18-release-announce\">https://nodejs.org/en/blog/announcements/v18-release-announce</a></li>\n<li><a href=\"https://nodejs.org/en/blog/release/v18.0.0/\">https://nodejs.org/en/blog/release/v18.0.0/</a></li>\n</ul>\n</div>",
		"title": "Node.js 18 新特性解读",
		"last_reply_at": "2022-05-22T01:29:31.258Z",
		"good": false,
		"top": true,
		"reply_count": 11,
		"visit_count": 24236,
		"create_at": "2022-04-22T09:12:32.716Z",
		"author": {
			"loginname": "atian25",
			"avatar_url": "https://avatars.githubusercontent.com/u/227713?v=4&s=120"
		}
	}, {
		"id": "61f69e4aa08b39f75309c2a8",
		"author_id": "4efc278525fa69ac6900000f",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://registry.npmmirror.com\">https://registry.npmmirror.com</a> 中国 npm 镜像源在2013年12月开始就使用基于 koa 的 <a href=\"https://github.com/cnpm/cnpmjs.org\">https://github.com/cnpm/cnpmjs.org</a> 私有 npm 应用搭建，这些年 node 应用框架在快速换代升级，连我们自己造的 egg 都要升级到 TypeScript 了，所以在 2021 年我们启动了 <a href=\"http://cnpmjs.org\">cnpmjs.org</a> 的技术升级重构，基于 egg 的 TypeScript 模式重新实现 <a href=\"https://github.com/cnpm/cnpmcore\">https://github.com/cnpm/cnpmcore</a> 。</p>\n<p>npm registry 的接口是 100% 实现迁移，然后在数据同步上通过数据库实现足够简单的任务系统，已经在 2022年1月30日完全老数据迁移。\n非常感谢阿里云这么多年来的对中国 npm 镜像云服务器的开源赞助，只能靠仅有的广告位和每年的感谢帖子来回报这份天价的云资源账单。这一次重构之后，我们验证下来至少可以节省一半的云服务器资源，也算是让阿里云的开源赞助可以减轻一些成本负担。</p>\n<p>当然 cnpmcore 不仅仅是为了技术升级，我们的核心新能力会跟随 npmfs 黑科技在 2022 年发布出来，到时候 npm install 的安装速度会在 cli 侧和 registry 侧同时发力，让 npm 模块安装速度在可预见的未来达到秒级。</p>\n<p>PS：预估你在此期间遇到包数据同步和丢失问题，请先手动同步一次，如果还是没有，请回帖反馈给我们。</p>\n</div>",
		"title": "中国 npm 镜像源升级公告",
		"last_reply_at": "2022-04-23T11:49:47.135Z",
		"good": false,
		"top": true,
		"reply_count": 4,
		"visit_count": 59291,
		"create_at": "2022-01-30T14:18:50.170Z",
		"author": {
			"loginname": "fengmk2",
			"avatar_url": "https://avatars.githubusercontent.com/u/156269?v=4&s=120"
		}
	}, {
		"id": "61dbd8fd994582918ef7d174",
		"author_id": "54009f5ccd66f2eb37190485",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>很多人觉得Node.js没有往年那么火了，事实上不是这样的，Node.js社区健康稳步的发展中，主要是从性能好向好用转变，在易用性上有很大提升，从Node.js源码更新的内容看，大抵如此。Node.js Diagnostics Working Group是近二年Node.js社区的重点工作组，Node.js 14版本之后的大部分功能特性都是这个工作组推动的。早在2015年，有2个跟踪工作组tracing WG 和事后分析工作组 postmortem WG，在2017年合并到Diagnostics WG。核心产出是async_hooks, profiling, tracing, dump debug, report等，都是在易用性和好用性上做提升。让每个Node.js开发者更低门槛的提升Node.js应用的开发体验。</p>\n<p>秦粤老师在《浮华过后的Node.js》分享里，也表达了同样观点，他用的是产品化平缓期，也是健康稳步的发展的意思。</p>\n<p><img src=\"//static.cnodejs.org/FqRK1Uehhaz3lFDF3oHeL97Z7zYm\" alt=\"image.png\"></p>\n<p>社区方面，Web框架已经没有多少空间，以特性取胜的框架，应该不会很多，比较期待Egg3。像fastify这种，修改Node.js机制，在性能领域深耕的框架，目前看是比较有作为的。pnpm是有创新的，但代码是有点可读性不太好。我更加喜欢rushstack对menorepo的改进，大规模编程范式还需要探索。除了去年提的midway-hooks，easy-monitor，看起来remix和morden算新，但还没有超出之前的范畴。</p>\n<p>下面结合《<a href=\"https://nodersurvey.github.io/reporters\">Node.js开发者2021报告</a>》内容，我们详细解读一下Node.js 2021年的情况。这份解读是根据冰森&amp;狼叔直播内容整理的，要点如下。\n​</p>\n<h3>1）开发框架变化较大，造轮子变少，TS变多，使用企业级框架变多</h3>\n<p>​</p>\n<p>去年express占比还非常高，今年企业级框架变多，尤其是大而全的框架更受欢迎。</p>\n<p><img src=\"//static.cnodejs.org/Fl-QFKuag-dvFGbx7Q45WabMH5d8\" alt=\"image.png\"></p>\n<p>Egg在国内普及率很高，而Midway和Nest增长较快，其实和TS普及有一定关系。\n​\n<img src=\"//static.cnodejs.org/FvoNa6PGZJN1ZaqZlmXZuRnNUI5_\" alt=\"image.png\">\n​</p>\n<h3>2）版本更新变化较大，从Node 12升级到Node 14，升级比较积极</h3>\n<p>​</p>\n<p>去年Node.js主要是使用Node 12，2021年Node 14占比将近一半，更新还是较快的。</p>\n<p><img src=\"//static.cnodejs.org/FpQcq4qzd9rl-R-VEXzLZAiVMPaa\" alt=\"image.png\">\n​</p>\n<h3>3）吐槽变多，意味着用的人变多，趋于成熟</h3>\n<p>​</p>\n<p>C++之父Bjarne Stroustrup说过：世界上只有两种编程语言,一种是整天被人骂的,还有一种是没人用的。\n​</p>\n<p>大家对Node.js吐槽变多，实际上是在应用场景上使用较多，不再是针对于某些特性而进行吹捧。回归理性，在真实应用场景上，分布广泛，核心围绕API和BFF层，CLI&amp;工具。\n​\n<img src=\"//static.cnodejs.org/FkEeeI7hvEdSMIyUNaKxnQx9pzcJ\" alt=\"image.png\"></p>\n<h3>4）出圈：年龄分布较去年比变大，使用工种也变得比较丰富。</h3>\n<p>除了应用场景上，分布广泛外，非前端意外的开发者相关角色也有很大比例的提升，比如架构师，技术总监，项目经理等都一定程度上使用Node.js。可以说Node.js走出了前端圈，面向更大群体提供服务。另外受访者的年龄分布也变大了，这和出圈是有直接关系的。\n​\n<img src=\"//static.cnodejs.org/FsnHAf1Map8P8i4bEAn89POQf_8E\" alt=\"image.png\"></p>\n<h3>5）使用困惑：性能优化，内存泄漏以及npm依赖</h3>\n<p>​</p>\n<p>以往对Node.js困惑最多的是异步流程控制，随着async/await的普及，这个问题已经慢慢在弱化。随着开发者使用Node.js深度增加，对性能优化，内存泄漏更为关注，这也是比较容易理解的。</p>\n<p><img src=\"//static.cnodejs.org/FkPiwL5U9kbNq1vUE1J8AQKn54z4\" alt=\"image.png\"></p>\n<p>​</p>\n<h3>6）未来：从业经验越高则越关注性能和 Serverless</h3>\n<p>​</p>\n<p>关注性能比较容易理解，关注Serverless最主要是的原因是Serverless可以做到低运维甚至是0运维。运维作为Node.js开发者必备技能，Serverless的出现使得很多非专业Node.js也能轻松搞定Node.js各种服务端场景。</p>\n<p><img src=\"//static.cnodejs.org/FjZSOZ1uO-Tqh8yTL2E4CtvMUFbN\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FshPaWkMvnMKMxJckqf0L-M5OYe1\" alt=\"image.png\"></p>\n<h3>推荐阅读</h3>\n<ul>\n<li>天猪《EggJS 的前世今生与未来》，比较期待Egg3，easy-monitor作者一君也加入Egg3项目组了 <a href=\"https://www.yuque.com/atian25/blog/egg-1to2to3\">https://www.yuque.com/atian25/blog/egg-1to2to3</a></li>\n<li>秦粤 《浮华过后的Node.js》链接稍后给出来</li>\n</ul>\n<h3>参考</h3>\n<ul>\n<li>原文  <a href=\"https://cnodejs.org/topic/6108bbc2a5d29d175c2d4208\">https://cnodejs.org/topic/6108bbc2a5d29d175c2d4208</a></li>\n<li>报告 <a href=\"https://nodersurvey.github.io/reporters\">https://nodersurvey.github.io/reporters</a></li>\n</ul>\n<p>如果大家想参与讨论，欢迎回复</p>\n</div>",
		"title": "Node.js 2021年开发者报告解读：健康稳步的发展中",
		"last_reply_at": "2022-04-23T02:24:23.220Z",
		"good": false,
		"top": true,
		"reply_count": 8,
		"visit_count": 183974,
		"create_at": "2022-01-10T06:58:05.059Z",
		"author": {
			"loginname": "i5ting",
			"avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
		}
	}, {
		"id": "618e06dbe6c91a00a3916cae",
		"author_id": "4f447c2f0a8abae26e01b27d",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><blockquote>\n<p>知乎原文地址：<a href=\"https://zhuanlan.zhihu.com/p/430580607\">https://zhuanlan.zhihu.com/p/430580607</a></p>\n</blockquote>\n<h2>源起</h2>\n<p>淘宝 NPM 镜像站（<a href=\"http://npm.taobao.org\">npm.taobao.org</a>）自 <a href=\"https://www.yuque.com/egg/data/taobaonpm#7f2e\">2014 年</a> 正式对外服务，一开始只是想简单地做 NPM 的中国镜像站点，回馈国内前端社区，不知不觉竟然一直运行到现在。当年参考 <code>Ruby Gems 淘宝镜像</code> 的方式，跟阿里开源组织申请了 <a href=\"http://taobao.org\">taobao.org</a> 的二级域名，镜像站点名称也自然而然地取名为 <code>淘宝 NPM 镜像站</code> （下称 CNPM）。</p>\n<p><img src=\"//static.cnodejs.org/Fuab0SKMfdsQUQZlbySva7BKTZsM\" alt=\"cnpm.png\"></p>\n<blockquote>\n<p>图片来源：<a href=\"https://time.graphics/line/579718\">https://time.graphics/line/579718</a></p>\n</blockquote>\n<p>如上图，从 2014 年 CNPM 正式提供服务到今天，NPM 包从 10 万 → 178 万，CNPM 的包下载量从 1 亿 → 200 亿（未包含阿里等私有源）。\n<strong>​</strong></p>\n<p><strong>可以毫不谦虚的说， CNPM 见证了国内前端蓬勃发展的这 8 年</strong>，未来我们希望继续陪伴中国的前端开发者持续走下去。</p>\n<p>PS：虽然核心参与者大部分来自国内大厂，不过 CNPM 本身是一个中立的公益项目，日常巨大的运维费用均来自社区捐赠。</p>\n<hr>\n<h2>新的起航</h2>\n<p>随着前端的蓬勃发展， NPM 包数据量和内容复杂度仍在不断地加速增长，CNPM 当年的架构已经很难满足当今的形势。</p>\n<p>为了提供更稳定、更安全、更符合国家法律法规要求的镜像服务，我们今年启动了 CNPM 的优化工作：</p>\n<ul>\n<li><strong>启动新的域名。</strong></li>\n<li>Registry 全面重构，提升稳定性，降低同步失败率。</li>\n<li>CLI 优化，提升安装速度，去掉软连接等带来的兼容性问题。</li>\n<li>沉淀自企业级大规模应用的使用经验手册。</li>\n<li>等等。。。</li>\n</ul>\n<p>应该有不少开发者已经发现，访问淘宝 NPM 已经会自动 301 跳转到 <a href=\"https://npmmirror.com/\">npmmirror.com</a> 新域名，这是我们独立注册和备案的域名。</p>\n<ul>\n<li>Web 站点：<a href=\"https://npmmirror.com\">https://npmmirror.com</a></li>\n<li>Registry Endpoint：<a href=\"https://registry.npmmirror.com\">https://registry.npmmirror.com</a></li>\n</ul>\n<p>随着新的域名已经正式启用，老 <a href=\"http://npm.taobao.org\">npm.taobao.org</a> 和 <a href=\"http://registry.npm.taobao.org\">registry.npm.taobao.org</a> 域名将于 2022 年 05 月 31 日零时起停止服务。\n<strong>​</strong></p>\n<p><strong>恳请有强依赖老域名的各位开发者尽快更新到新域名，企业用户可能还需要联系网管/IT/SRE 更新防火墙白名单。</strong> 当然如果你使用的是 cnpm 的 CLI 命令行工具，我们会去全部替换并发布新版本，大家只需要重新安装到最小版本即可。</p>\n<p>我们深知更换域名并停止对老域名的支持是一种体验非常不好的事情，但为了能在符合网站合规运营要求的情况下，可以更长期可持续运行下去，我们还是最终做出这个更换域名的决定，再次说声抱歉。</p>\n<p>其他功能正在开发中，欢迎围观 <a href=\"https://github.com/cnpm/cnpmcore\">GitHub</a> ，更期待您能提 PR 参与开源共建。</p>\n<hr>\n<h2>特别感谢</h2>\n<p>非常感谢 <a href=\"https://developer.aliyun.com/mirror/\">阿里云开发者社区的开源镜像站</a> 对淘宝 NPM 镜像站这些年来的持续赞助，才让我们可以不为巨大流量和存储费用而烦恼，才让我们可以持续专注做好专业的技术工作。</p>\n<p>还要特别感谢 <a href=\"https://fed.taobao.org/\">淘宝前端团队</a>，帮助我们处理这些来年关于 <a href=\"http://npm.taobao.org\">npm.taobao.org</a> 的域名注册、证书更新、合规等许多复杂流程。</p>\n<p>最后，为了国内开发者能尽可能早的完成切换，我们厚着脸皮请求大家帮忙传播下，谢谢。</p>\n</div>",
		"title": "【望周知，求扩散】淘宝 NPM 镜像站喊你切换新域名啦",
		"last_reply_at": "2022-04-22T01:14:38.126Z",
		"good": false,
		"top": true,
		"reply_count": 11,
		"visit_count": 85454,
		"create_at": "2021-11-12T06:16:59.989Z",
		"author": {
			"loginname": "atian25",
			"avatar_url": "https://avatars.githubusercontent.com/u/227713?v=4&s=120"
		}
	}, {
		"id": "5fdb44d70f99cb37f45e3410",
		"author_id": "56f3686f02c237a73a1a8acf",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>RT.</p>\n<p>请大家遵守法律法规，勿发布不合规内容。</p>\n<ul>\n<li>2021/11/26：针对部分打擦边球的推广行为（如各种云服务商的推广链接），将会对账户做出屏蔽处理。</li>\n<li>2021/11/26：针对机器人频繁发布广告与违规内容，新增发帖限制如下：新用户五天内不允许发帖（不影响回帖）。</li>\n</ul>\n</div>",
		"title": "【2021/11/26】请大家遵纪守法，勿发布不合规内容",
		"last_reply_at": "2021-12-21T12:12:19.037Z",
		"good": false,
		"top": true,
		"reply_count": 226,
		"visit_count": 180175,
		"create_at": "2020-12-17T11:45:27.667Z",
		"author": {
			"loginname": "thonatos",
			"avatar_url": "https://avatars.githubusercontent.com/u/958063?v=4&s=120"
		}
	}, {
		"id": "6287588e79f90d432fa0e7be",
		"author_id": "59a50205bc6d953708128944",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fq-uEI8ruSrNS8-GBj_UWpCPfKg_\" alt=\"截屏2022-05-20 16.59.04.png\"></p>\n</div>",
		"title": "论坛是不是更冷清了。。。",
		"last_reply_at": "2022-05-23T02:54:23.681Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 215,
		"create_at": "2022-05-20T08:59:58.876Z",
		"author": {
			"loginname": "jxycbjhc",
			"avatar_url": "https://avatars0.githubusercontent.com/u/16661897?v=4&s=120"
		}
	}, {
		"id": "6289f95f79f90db287a0e8a5",
		"author_id": "5e350857267721420912ac31",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>周末花了两天时间收集了几百个网站的文档地址，类型从前端到后端全部覆盖了，还有一些热门的技术，也添加进来了，这里分享给大家，统一的入口地址在<a href=\"https://adochub.com\">adochub</a>.</p>\n<p><a href=\"https://docker.adochub.com/\">docker</a>\n<a href=\"https://nginx.adochub.com/\">nginx</a>\n<a href=\"https://python3.adochub.com/\">python3</a>\n<a href=\"https://meteor.adochub.com/\">meteor</a>\n<a href=\"https://prisma.adochub.com/\">prisma</a>\n<a href=\"https://vuejs.adochub.com/\">vuejs</a>\n<a href=\"https://anaconda.adochub.com/\">anaconda</a>\n<a href=\"https://caddyserver.adochub.com/\">caddy server</a>\n<a href=\"https://divio.adochub.com/\">divio</a>\n<a href=\"https://aws.adochub.com/\">aws</a>\n<a href=\"https://mongoosejs.adochub.com/\">mongoosejs</a>\n<a href=\"https://tidb.adochub.com/\">tidb</a>\n<a href=\"https://flutter.adochub.com/\">flutter</a>\n<a href=\"https://gitlab.adochub.com/\">gitlab</a>\n<a href=\"https://threejs.adochub.com/\">threejs</a>\n<a href=\"https://microsoft.adochub.com/\">microsoft</a>\n<a href=\"https://pytorch.adochub.com/\">pytorch</a>\n<a href=\"https://moodle.adochub.com/\">moodle</a>\n<a href=\"https://kubernetes.adochub.com/\">kubernetes</a>\n<a href=\"https://github.adochub.com/\">github</a>\n<a href=\"https://android.adochub.com/\">android</a>\n<a href=\"https://nodejs.adochub.com/\">nodejs</a>\n<a href=\"https://cyberark.adochub.com/\">cyberark</a>\n<a href=\"https://twitter.adochub.com/\">twitter</a>\n<a href=\"https://zoho.adochub.com/\">zoho</a>\n<a href=\"https://angular.adochub.com/\">angular</a>\n<a href=\"https://newrelic.adochub.com/\">newrelic</a>\n<a href=\"https://php.adochub.com/\">php</a>\n<a href=\"https://npmjs.adochub.com/\">npmjs</a>\n<a href=\"https://reactjs.adochub.com/\">reactjs</a>\n<a href=\"https://nestjs.adochub.com/\">nestjs</a>\n<a href=\"https://mongodb.adochub.com/\">mongodb</a>\n<a href=\"https://pulsar.adochub.com/\">pulsar</a>\n<a href=\"https://mozilla.adochub.com/\">mozilla</a>\n<a href=\"https://travis-ci.adochub.com/\">travis-ci</a>\n<a href=\"https://solana.adochub.com/\">solana</a>\n<a href=\"https://openstack.adochub.com/\">openstack</a>\n<a href=\"https://laravel.adochub.com/\">laravel</a>\n<a href=\"https://stripe.com/docs\">stripe</a>\n<a href=\"https://reactnative.adochub.com/\">react native</a>\n<a href=\"https://ansible.adochub.com/\">ansible</a>\n<a href=\"https://cypress.adochub.com/\">cypress</a>\n<a href=\"https://djangoproject.adochub.com/\">django project</a>\n<a href=\"https://auth0.adochub.com/\">auth0</a>\n<a href=\"https://godotengine.adochub.com/\">godotengine</a>\n<a href=\"https://apollographql.adochub.com/\">apollo graphql</a>\n<a href=\"https://getbootstrap.adochub.com/\">getbootstrap</a>\n<a href=\"https://readthedocs.adochub.com/\">readthedocs</a>\n<a href=\"https://oracle.adochub.com/\">oracle</a>\n<a href=\"https://tailwindcss.adochub.com/\">tailwindcss</a>\n<a href=\"https://ubuntu.adochub.com/\">ubuntu</a>\n<a href=\"https://netlify.adochub.com/\">netlify</a>\n<a href=\"https://amplify.adochub.com/\">amplify</a>\n<a href=\"https://vaultproject.adochub.com/\">vault project</a>\n<a href=\"https://kotlinlang.adochub.com/\">kotlin lang</a>\n<a href=\"https://momentjs.adochub.com/\">momentjs</a>\n<a href=\"https://developers.cloudflare.com/docs\">cloudflare</a>\n<a href=\"https://sublimetext.adochub.com/\">sublimetext</a>\n<a href=\"https://nvidia.adochub.com/\">nvidia</a>\n<a href=\"https://prettier.adochub.com/\">prettier</a>\n<a href=\"https://pandas.adochub.com/\">pandas</a>\n<a href=\"https://pythonguide.adochub.com/\">python guide</a>\n<a href=\"https://yarn.adochub.com/\">yarn</a>\n<a href=\"https://fasttext.adochub.com/\">fasttext</a>\n<a href=\"https://rancher.adochub.com/\">rancher</a>\n<a href=\"https://postgresql.adochub.com/\">postgresql</a>\n<a href=\"https://remix.adochub.com/\">remix</a>\n<a href=\"https://apachehttpd.adochub.com/\">apache httpd</a>\n<a href=\"https://pig.adochub.com/\">pig</a>\n<a href=\"https://async.adochub.com/\">async</a>\n<a href=\"https://babeljs.adochub.com/\">babeljs</a>\n<a href=\"https://backbonejs.adochub.com/\">backbonejs</a>\n<a href=\"https://bash.adochub.com/\">bash</a>\n<a href=\"https://bluebirdjs.adochub.com/\">bluebirdjs</a>\n<a href=\"https://bottlepy.adochub.com/\">bottlepy</a>\n<a href=\"https://bower.adochub.com/\">bower</a>\n<a href=\"https://cplusplus.adochub.com/\">cplusplus</a>\n<a href=\"https://clanguage.adochub.com/\">c language</a>\n<a href=\"https://wikipedia.adochub.com/\">wikipedia</a>\n<a href=\"https://cakephp.adochub.com/\">cakephp</a>\n<a href=\"https://chaijs.adochub.com/\">chaijs</a>\n<a href=\"https://chef.adochub.com/\">chef</a>\n<a href=\"https://clojure.adochub.com/\">clojure</a>\n<a href=\"https://cmake.adochub.com/\">cmake</a>\n<a href=\"https://codeception.adochub.com/\">codeception</a>\n<a href=\"https://codecept.adochub.com/\">codecept</a>\n<a href=\"https://codeigniter4.adochub.com/\">codeigniter4</a>\n<a href=\"https://coffeescript.adochub.com/\">coffeescript</a>\n<a href=\"https://composer.adochub.com/\">composer</a>\n<a href=\"https://cordova.adochub.com/\">cordova</a>\n<a href=\"https://crystallang.adochub.com/\">crystal lang</a>\n<a href=\"https://dlang.adochub.com/\">d lang</a>\n<a href=\"https://d3js.adochub.com/\">d3js</a>\n<a href=\"https://dartlang.adochub.com/\">dart lang</a>\n<a href=\"https://deno.adochub.com/\">deno</a>\n<a href=\"https://dojo.adochub.com/\">dojo</a>\n<a href=\"https://drupal.adochub.com/\">drupal</a>\n<a href=\"https://electronjs.adochub.com/\">electronjs</a>\n<a href=\"https://emacs.adochub.com/\">emacs</a>\n<a href=\"https://elixirlang.adochub.com/\">elixir lang</a>\n<a href=\"https://emberjs.adochub.com/\">emberjs</a>\n<a href=\"https://enzymejs.adochub.com/\">enzymejs</a>\n<a href=\"https://erlang.adochub.com/\">erlang</a>\n<a href=\"https://esbuild.adochub.com/\">esbuild</a>\n<a href=\"https://eslint.adochub.com/\">eslint</a>\n<a href=\"https://expressjs.adochub.com/\">expressjs</a>\n<a href=\"https://eggjs.adochub.com/\">eggjs</a>\n<a href=\"https://falcon.adochub.com/\">falcon</a>\n<a href=\"https://fishshell.adochub.com/\">fishshell</a>\n<a href=\"https://flask.adochub.com/\">flask</a>\n<a href=\"https://algolia.adochub.com/\">algolia</a>\n<a href=\"https://flow.adochub.com/\">flow</a>\n<a href=\"https://gcc.adochub.com/\">gcc</a>\n<a href=\"https://git.adochub.com/\">git</a>\n<a href=\"https://fortrancompiler.adochub.com/\">fortran compiler</a>\n<a href=\"https://make.adochub.com/\">make</a>\n<a href=\"https://cobol.adochub.com/\">cobol</a>\n<a href=\"https://gnuplot.adochub.com/\">gnuplot</a>\n<a href=\"https://golang.adochub.com/\">go lang</a>\n<a href=\"https://graphite.adochub.com/\">graphite</a>\n<a href=\"https://groovylang.adochub.com/\">groovy lang</a>\n<a href=\"https://gruntjs.adochub.com/\">gruntjs</a>\n<a href=\"https://gtk4.adochub.com/\">gtk4</a>\n<a href=\"https://handlebarsjs.adochub.com/\">handlebarsjs</a>\n<a href=\"https://haproxy.adochub.com/\">haproxy</a>\n<a href=\"https://haskell.adochub.com/\">haskell</a>\n<a href=\"https://haxe.adochub.com/\">haxe</a>\n<a href=\"https://homebrew.adochub.com/\">homebrew</a>\n<a href=\"https://i3.adochub.com/\">i3</a>\n<a href=\"https://immutablejs.adochub.com/\">immutablejs</a>\n<a href=\"https://influxdata.adochub.com/\">influxdata</a>\n<a href=\"https://jasmine.adochub.com/\">jasmine</a>\n<a href=\"https://jekyll.adochub.com/\">jekyll</a>\n<a href=\"https://jestjs.adochub.com/\">jestjs</a>\n<a href=\"https://jinja.adochub.com/\">jinja</a>\n<a href=\"https://jquery.adochub.com/\">jquery</a>\n<a href=\"https://jqueryui.adochub.com/\">jquery ui</a>\n<a href=\"https://jsdoc.adochub.com/\">jsdoc</a>\n<a href=\"https://julialang.adochub.com/\">julia lang</a>\n<a href=\"https://knockoutjs.adochub.com/\">knockoutjs</a>\n<a href=\"https://koajs.adochub.com/\">koajs</a>\n<a href=\"https://latexproject.adochub.com/\">latex project</a>\n<a href=\"https://leafletjs.adochub.com/\">leafletjs</a>\n<a href=\"https://lesscss.adochub.com/\">less css</a>\n<a href=\"https://liquid.adochub.com/\">liquid</a>\n<a href=\"https://lodash.adochub.com/\">lodash</a>\n<a href=\"https://lualang.adochub.com/\">lua lang</a>\n<a href=\"https://love.adochub.com/\">love</a>\n<a href=\"https://mariadb.adochub.com/\">mariadb</a>\n<a href=\"https://marionettejs.adochub.com/\">marionettejs</a>\n<a href=\"https://markdown.adochub.com/\">markdown</a>\n<a href=\"https://matplotlib.adochub.com/\">matplotlib</a>\n<a href=\"https://mochajs.adochub.com/\">mochajs</a>\n<a href=\"https://modernizr.adochub.com/\">modernizr</a>\n<a href=\"https://mimlang.adochub.com/\">mim lang</a>\n<a href=\"https://nokogiri.adochub.com/\">nokogiri</a>\n<a href=\"https://numpy.adochub.com/\">numpy</a>\n<a href=\"https://ocamllang.adochub.com/\">ocaml lang</a>\n<a href=\"https://octave.adochub.com/\">octave</a>\n<a href=\"https://openjdk.adochub.com/\">openjdk</a>\n<a href=\"https://opentsdb.adochub.com/\">opentsdb</a>\n<a href=\"https://padrinorb.adochub.com/\">padrinorb</a>\n<a href=\"https://perllang.adochub.com/\">perl lang</a>\n<a href=\"https://phalcon.adochub.com/\">phalcon</a>\n<a href=\"https://phaser.adochub.com/\">phaser</a>\n<a href=\"https://phoenix.adochub.com/\">phoenix</a>\n<a href=\"https://phpunit.adochub.com/\">phpunit</a>\n<a href=\"https://pugjs.adochub.com/\">pugjs</a>\n<a href=\"https://puppeteer.adochub.com/\">puppeteer</a>\n<a href=\"https://pygame.adochub.com/\">pygame</a>\n<a href=\"https://angularjs.adochub.com/\">angularjs</a>\n<a href=\"https://qt.adochub.com/\">qt</a>\n<a href=\"https://rlang.adochub.com/\">r lang</a>\n<a href=\"https://ramdajs.adochub.com/\">ramdajs</a>\n<a href=\"https://react-bootstrap.adochub.com/\">react-bootstrap</a>\n<a href=\"https://reactrouter.adochub.com/\">react router</a>\n<a href=\"https://reactivex.adochub.com/\">reactivex</a>\n<a href=\"https://redis.adochub.com/\">redis</a>\n<a href=\"https://redux.adochub.com/\">redux</a>\n<a href=\"https://relay.adochub.com/\">relay</a>\n<a href=\"https://requirejs.adochub.com/\">requirejs</a>\n<a href=\"https://rethinkdb.adochub.com/\">rethinkdb</a>\n<a href=\"https://rubylang.adochub.com/\">ruby lang</a>\n<a href=\"https://rubyonrails.adochub.com/\">rubyonrails</a>\n<a href=\"https://rustlang.adochub.com/\">rust lang</a>\n<a href=\"https://rxjs.adochub.com/\">rxjs</a>\n<a href=\"https://saltproject.adochub.com/\">saltproject</a>\n<a href=\"https://sasslang.adochub.com/\">sass lang</a>\n<a href=\"https://scalalang.adochub.com/\">scala lang</a>\n<a href=\"https://scikitimage.adochub.com/\">scikit image</a>\n<a href=\"https://scikitlearn.adochub.com/\">scikit learn</a>\n<a href=\"https://sequelize.adochub.com/\">sequelize</a>\n<a href=\"https://sinonjs.adochub.com/\">sinonjs</a>\n<a href=\"https://socketio.adochub.com/\">socket.io</a>\n<a href=\"https://spring-boot.adochub.com/\">spring-boot</a>\n<a href=\"https://sqlite.adochub.com/\">sqlite</a>\n<a href=\"https://statsmodels.adochub.com/\">statsmodels</a>\n<a href=\"https://symfony.adochub.com/\">symfony</a>\n<a href=\"https://tcltk.adochub.com/\">tcl.tk</a>\n<a href=\"https://tensorflow.adochub.com/\">tensorflow</a>\n<a href=\"https://terraform.adochub.com/\">terraform</a>\n<a href=\"https://trio.adochub.com/\">trio</a>\n<a href=\"https://twig.adochub.com/\">twig</a>\n<a href=\"https://typescriptlang.adochub.com/\">typescriptlang</a>\n<a href=\"https://underscorejs.adochub.com/\">underscorejs</a>\n<a href=\"https://vagrant.adochub.com/\">vagrant</a>\n<a href=\"https://vitejs.adochub.com/\">vitejs</a>\n<a href=\"https://vuerouter.adochub.com/\">vue router</a>\n<a href=\"https://vuex.adochub.com/\">vuex</a>\n<a href=\"https://vulkan.adochub.com/\">vulkan</a>\n<a href=\"https://webpack.adochub.com/\">webpack</a>\n<a href=\"https://werkzeug.adochub.com/\">werkzeug</a>\n<a href=\"https://wordpress.adochub.com/\">wordpress</a>\n<a href=\"https://yiiframework.adochub.com/\">yiiframework</a>\n<a href=\"https://ziglang.adochub.com/\">ziglang</a>\n<a href=\"https://jqueryobile.adochub.com/\">jquery mobile</a>\n<a href=\"https://twilio.adochub.com/\">twilio</a>\n<a href=\"https://paypal.adochub.com/\">paypal</a>\n<a href=\"https://apigee.adochub.com/\">apigee</a>\n<a href=\"https://googleevelopers.adochub.com/\">google developers</a>\n<a href=\"https://nunjucks.adochub.com/\">nunjucks</a>\n<a href=\"https://unity3d.adochub.com/\">unity3d</a>\n<a href=\"https://attic.adochub.com/\">attic</a>\n<a href=\"https://dbeaver.adochub.com/\">dbeaver</a>\n<a href=\"https://mysql.adochub.com/\">mysql</a>\n<a href=\"https://antdesign.adochub.com/\">ant.design</a>\n<a href=\"https://medium.adochub.com/\">medium</a>\n<a href=\"https://Antesignfue.adochub.com/\">Ant Design of Vue</a>\n<a href=\"https://Materialesign.adochub.com/\">Material Design 3</a>\n<a href=\"https://apisix.adochub.com/\">apisix</a>\n<a href=\"https://w3schools.adochub.com/\">w3schools</a>\n<a href=\"https://apacheccumulo.adochub.com/\">apache accumulo</a>\n<a href=\"https://apachectivemq.adochub.com/\">apache activemq</a>\n<a href=\"https://apacheirflow.adochub.com/\">apache airflow</a>\n<a href=\"https://apachellura.adochub.com/\">apache allura</a>\n<a href=\"https://apacheny23.adochub.com/\">apache any23</a>\n<a href=\"https://apacherchiva.adochub.com/\">apache archiva</a>\n<a href=\"https://apacherrow.adochub.com/\">apache arrow</a>\n<a href=\"https://apachevro.adochub.com/\">apache avro</a>\n<a href=\"https://apacheval.adochub.com/\">apache bval</a>\n<a href=\"https://apacheahir.adochub.com/\">apache bahir</a>\n<a href=\"https://apacheeam.adochub.com/\">apache beam</a>\n<a href=\"https://apacheIGTOP.adochub.com/\">apache BIGTOP</a>\n<a href=\"https://apacheookkeeper.adochub.com/\">apache bookkeeper</a>\n<a href=\"https://apacherooklyn.adochub.com/\">apache brooklyn</a>\n<a href=\"https://apacheuildr.adochub.com/\">apache buildr</a>\n<a href=\"https://firebase.adochub.com/\">firebase</a>\n<a href=\"https://apachexf.adochub.com/\">apache cxf</a>\n<a href=\"https://apachealcite.adochub.com/\">apache calcite</a>\n<a href=\"https://apacheamel.adochub.com/\">apache camel</a>\n<a href=\"https://capacherbondata.adochub.com/\">capache arbondata</a>\n<a href=\"https://apacheassandra.adochub.com/\">apache cassandra</a>\n<a href=\"https://apacheayenne.adochub.com/\">apache cayenne</a>\n<a href=\"https://apacheelix.adochub.com/\">apache celix</a>\n<a href=\"https://apachelerezza.adochub.com/\">apache clerezza</a>\n<a href=\"https://apacheloudstack.adochub.com/\">apache cloudstack</a>\n<a href=\"https://apacheocoon.adochub.com/\">apache cocoon</a>\n<a href=\"https://apacheommons.adochub.com/\">apache commons</a>\n<a href=\"https://apacheouchdb.adochub.com/\">apache couchdb</a>\n<a href=\"https://apacheurator.adochub.com/\">apache curator</a>\n<a href=\"https://apachetakes.adochub.com/\">apache ctakes</a>\n<a href=\"https://apacheaffodil.adochub.com/\">apache daffodil</a>\n<a href=\"https://apacheatafu.adochub.com/\">apache datafu</a>\n<a href=\"https://apacheatasketches.adochub.com/\">apache datasketches</a>\n<a href=\"https://apacheeltaspike.adochub.com/\">apache deltaspike</a>\n<a href=\"https://apacheolphinscheduler.adochub.com/\">apache dolphinscheduler</a>\n<a href=\"https://apacherill.adochub.com/\">apache drill</a>\n<a href=\"https://apacheruid.adochub.com/\">apache druid</a>\n<a href=\"https://apacheubbo.adochub.com/\">apache dubbo</a>\n<a href=\"https://apachecharts.adochub.com/\">apache echarts</a>\n<a href=\"https://apachelex.adochub.com/\">apache flex</a>\n<a href=\"https://apachelume.adochub.com/\">apache flume</a>\n<a href=\"https://apacheluo.adochub.com/\">apache fluo</a>\n<a href=\"https://apachereemarker.adochub.com/\">apache freemarker</a>\n<a href=\"https://apacheeode.adochub.com/\">apache geode</a>\n<a href=\"https://apacheiraph.adochub.com/\">apache giraph</a>\n<a href=\"https://apacheobblin.adochub.com/\">apache gobblin</a>\n<a href=\"https://apacheriffin.adochub.com/\">apache griffin</a>\n<a href=\"https://apacheuacamole.adochub.com/\">apache guacamole</a>\n<a href=\"https://apacheawq.adochub.com/\">apache hawq</a>\n<a href=\"https://apachebase.adochub.com/\">apache hbase</a>\n<a href=\"https://apacheadoop.adochub.com/\">apache hadoop</a>\n<a href=\"https://apacheop.adochub.com/\">apache hop</a>\n<a href=\"https://ApachettpComponents.adochub.com/\">Apache HttpComponents</a>\n<a href=\"https://apacheudi.adochub.com/\">apache hudi</a>\n<a href=\"https://apacheceberg.adochub.com/\">apache iceberg</a>\n<a href=\"https://apachegnite.adochub.com/\">apache ignite</a>\n<a href=\"https://apachempala.adochub.com/\">apache impala</a>\n<a href=\"https://apacheotdb.adochub.com/\">apache iotdb</a>\n<a href=\"https://apachesis.adochub.com/\">apache isis</a>\n<a href=\"https://apachemeter.adochub.com/\">apache jmeter</a>\n<a href=\"https://apachespwiki.adochub.com/\">apache jspwiki</a>\n<a href=\"https://apacheackrabbit.adochub.com/\">apache jackrabbit</a>\n<a href=\"https://apacheames.adochub.com/\">apache james</a>\n<a href=\"https://apacheena.adochub.com/\">apache jena</a>\n<a href=\"https://apacheohnzon.adochub.com/\">apache johnzon</a>\n<a href=\"https://nextjs.adochub.com/\">nextjs</a>\n<a href=\"https://apacheclouds.adochub.com/\">apache jclouds</a>\n<a href=\"https://ghost.adochub.com/\">ghost</a>\n<a href=\"https://apacheafka.adochub.com/\">apache kafka</a>\n<a href=\"https://apachearaf.adochub.com/\">apache karaf</a>\n<a href=\"https://apacheibble.adochub.com/\">apache kibble</a>\n<a href=\"https://apachenox.adochub.com/\">apache knox</a>\n<a href=\"https://apacheudu.adochub.com/\">apache kudu</a>\n<a href=\"https://apacheylin.adochub.com/\">apache kylin</a>\n<a href=\"https://apacheibcloud.adochub.com/\">apache libcloud</a>\n<a href=\"https://apacheogging.adochub.com/\">apache logging</a>\n<a href=\"https://apacheucene.adochub.com/\">apache lucene</a>\n<a href=\"https://apacheina.adochub.com/\">apache mina</a>\n<a href=\"https://apacheaven.adochub.com/\">apache maven</a>\n<a href=\"https://apacheesos.adochub.com/\">apache mesos</a>\n<a href=\"https://apachenemonic.adochub.com/\">apache mnemonic</a>\n<a href=\"https://apacheyfaces.adochub.com/\">apache myfaces</a>\n<a href=\"https://apacheetbeans.adochub.com/\">apache netbeans</a>\n<a href=\"https://apacheifi.adochub.com/\">apache nifi</a>\n<a href=\"https://apacheutch.adochub.com/\">apache nutch</a>\n<a href=\"https://apacherc.adochub.com/\">apache orc</a>\n<a href=\"https://apachelingo.adochub.com/\">apache olingo</a>\n<a href=\"https://apacheozie.adochub.com/\">apache oozie</a>\n<a href=\"https://apachepennlp.adochub.com/\">apache opennlp</a>\n<a href=\"https://apachepenwebbeans.adochub.com/\">apache openwebbeans</a>\n<a href=\"https://apachezone.adochub.com/\">apache ozone</a>\n<a href=\"https://apachedfbox.adochub.com/\">apache pdfbox</a>\n<a href=\"https://apacheoi.adochub.com/\">apache poi</a>\n<a href=\"https://apachearquet.adochub.com/\">apache parquet</a>\n<a href=\"https://apacheerl.adochub.com/\">apache perl</a>\n<a href=\"https://apachehoenix.adochub.com/\">apache phoenix</a>\n<a href=\"https://apacheig.adochub.com/\">apache pig</a>\n<a href=\"https://apacheinot.adochub.com/\">apache pinot</a>\n<a href=\"https://apacheivot.adochub.com/\">apache pivot</a>\n<a href=\"https://apachepr.adochub.com/\">apache apr</a>\n<a href=\"https://apacheortals.adochub.com/\">apache portals</a>\n<a href=\"https://apachepid.adochub.com/\">apache qpid</a>\n<a href=\"https://apacheeef.adochub.com/\">apache reef</a>\n<a href=\"https://apacheanger.adochub.com/\">apache ranger</a>\n<a href=\"https://apacheocketmq.adochub.com/\">apache rocketmq</a>\n<a href=\"https://apacheoyale.adochub.com/\">apache royale</a>\n<a href=\"https://apacheinga.adochub.com/\">apache singa</a>\n<a href=\"https://apacheis.adochub.com/\">apache sis</a>\n<a href=\"https://apacheamza.adochub.com/\">apache samza</a>\n<a href=\"https://apacheantuario.adochub.com/\">apache santuario</a>\n<a href=\"https://apacheervicecomb.adochub.com/\">apache servicecomb</a>\n<a href=\"https://apacheervicemix.adochub.com/\">apache servicemix</a>\n<a href=\"https://apachehiro.adochub.com/\">apache shiro</a>\n<a href=\"https://apachekywalking.adochub.com/\">apache skywalking</a>\n<a href=\"https://apacheling.adochub.com/\">apache sling</a>\n<a href=\"https://apacheolr.adochub.com/\">apache solr</a>\n<a href=\"https://apachepark.adochub.com/\">apache spark</a>\n<a href=\"https://apachetorm.adochub.com/\">apache storm</a>\n<a href=\"https://apachetreams.adochub.com/\">apache streams</a>\n<a href=\"https://apachetruts.adochub.com/\">apache struts</a>\n<a href=\"https://apacheubmarine.adochub.com/\">apache submarine</a>\n<a href=\"https://apacheubversion.adochub.com/\">apache subversion</a>\n<a href=\"https://apacheuperset.adochub.com/\">apache superset</a>\n<a href=\"https://apacheynapse.adochub.com/\">apache synapse</a>\n<a href=\"https://apacheystemds.adochub.com/\">apache systemds</a>\n<a href=\"https://apachevm.adochub.com/\">apache tvm</a>\n<a href=\"https://apacheapestry.adochub.com/\">apache tapestry</a>\n<a href=\"https://apacheez.adochub.com/\">apache tez</a>\n<a href=\"https://apachehrift.adochub.com/\">apache thrift</a>\n<a href=\"https://apacheika.adochub.com/\">apache tika</a>\n<a href=\"https://apacheomee.adochub.com/\">apache tomee</a>\n<a href=\"https://apacheomcat.adochub.com/\">apache tomcat</a>\n<a href=\"https://apacherafficcontrol.adochub.com/\">apache trafficcontrol</a>\n<a href=\"https://apacherafficserver.adochub.com/\">apache trafficserver</a>\n<a href=\"https://apacheima.adochub.com/\">apache uima</a>\n<a href=\"https://unomi.adochub.com/\">unomi</a>\n<a href=\"https://apacheelocity.adochub.com/\">apache velocity</a>\n<a href=\"https://apacheicket.adochub.com/\">apache wicket</a>\n<a href=\"https://apacheetus.adochub.com/\">apache yetus</a>\n<a href=\"https://apacheunikorn.adochub.com/\">apache yunikorn</a>\n<a href=\"https://apacheeppelin.adochub.com/\">apache zeppelin</a>\n<a href=\"https://apacheookeeper.adochub.com/\">apache zookeeper</a>\n<a href=\"https://hexo.adochub.com/\">hexo</a>\n<a href=\"https://hugo.adochub.com/\">hugo</a>\n<a href=\"https://coredns.adochub.com/\">coredns</a>\n<a href=\"https://envoyproxy.adochub.com/\">envoyproxy</a>\n<a href=\"https://etcd.adochub.com/\">etcd</a>\n<a href=\"https://fluentd.adochub.com/\">fluentd</a>\n<a href=\"https://harbor.adochub.com/\">harbor</a>\n<a href=\"https://helm.adochub.com/\">helm</a>\n<a href=\"https://linkerd.adochub.com/\">linkerd</a>\n<a href=\"https://asterixdb.adochub.com/\">asterixdb</a>\n<a href=\"https://atlas.adochub.com/\">atlas</a>\n<a href=\"https://openpolicyagent.adochub.com/\">openpolicyagent</a>\n<a href=\"https://prometheus.adochub.com/\">prometheus</a>\n<a href=\"https://rook.adochub.com/\">rook</a>\n<a href=\"https://theupdateframework.adochub.com/\">theupdateframework</a>\n<a href=\"https://tikv.adochub.com/\">tikv</a>\n<a href=\"https://vitess.adochub.com/\">vitess</a>\n<a href=\"https://backstage.adochub.com/\">backstage</a>\n<a href=\"https://buildpacks.adochub.com/\">buildpacks</a>\n<a href=\"https://chaos-mesh.adochub.com/\">chaos-mesh</a>\n<a href=\"https://cilium.adochub.com/\">cilium</a>\n<a href=\"https://Cloudativeetwork.adochub.com/\">Cloud Native Network</a>\n<a href=\"https://contour.adochub.com/\">contour</a>\n<a href=\"https://cortexmetrics.adochub.com/\">cortexmetrics</a>\n<a href=\"https://cri-o.adochub.com/\">cri-o</a>\n<a href=\"https://crossplane.adochub.com/\">crossplane</a>\n<a href=\"https://dapr.adochub.com/\">dapr</a>\n<a href=\"https://Dragonfly.adochub.com/\">Dragonfly</a>\n<a href=\"https://falco.adochub.com/\">falco</a>\n<a href=\"https://flagger.adochub.com/\">flagger</a>\n<a href=\"https://fluxcd.adochub.com/\">fluxcd</a>\n<a href=\"https://grpc.adochub.com/\">grpc</a>\n<a href=\"https://keda.adochub.com/\">keda</a>\n<a href=\"https://knative.adochub.com/\">knative</a>\n<a href=\"https://kubeedge.adochub.com/\">kubeedge</a>\n<a href=\"https://kubevirt.adochub.com/\">kubevirt</a>\n<a href=\"https://litmuschaos.adochub.com/\">litmuschaos</a>\n<a href=\"https://longhorn.adochub.com/\">longhorn</a>\n<a href=\"https://nats.adochub.com/\">nats</a>\n<a href=\"https://opentelemetry.adochub.com/\">opentelemetry</a>\n<a href=\"https://spiffe.adochub.com/\">spiffe</a>\n<a href=\"https://volcano.adochub.com/\">volcano</a>\n<a href=\"https://vultr.adochub.com/\">vultr</a>\n<a href=\"https://strapi.adochub.com/\">strapi</a>\n<a href=\"https://webtorrent.adochub.com/\">webtorrent</a>\n<a href=\"https://animate.css.adochub.com/\">animate.css</a>\n<a href=\"https://animejs.adochub.com/\">animejs</a>\n<a href=\"https://akka.adochub.com/\">akka</a>\n<a href=\"https://apple.adochub.com/\">apple</a>\n<a href=\"https://arduino.adochub.com/\">arduino</a>\n<a href=\"https://googleloud.adochub.com/\">google cloud</a>\n<a href=\"https://elasticearch.adochub.com/\">elastic search</a>\n<a href=\"https://bitnami.adochub.com/\">bitnami</a>\n<a href=\"https://databricksws.adochub.com/\">databricks aws</a>\n<a href=\"https://databrickscp.adochub.com/\">databricks gcp</a>\n<a href=\"https://morpheusdata.adochub.com/\">morpheusdata</a>\n<a href=\"https://netapp.adochub.com/\">netapp</a>\n<a href=\"https://scorm.adochub.com/\">scorm</a>\n<a href=\"https://cloudfoundry.adochub.com/\">cloudfoundry</a>\n<a href=\"https://yandexloud.adochub.com/\">yandex cloud</a>\n<a href=\"https://vmware.adochub.com/\">vmware</a>\n<a href=\"https://ibmloud.adochub.com/\">ibm cloud</a>\n<a href=\"https://acquia.adochub.com/\">acquia</a>\n<a href=\"https://f5loud.adochub.com/\">f5 cloud</a>\n<a href=\"https://fortinet.adochub.com/\">fortinet</a>\n<a href=\"https://splunk.adochub.com/\">splunk</a>\n<a href=\"https://k6.adochub.com/\">k6</a>\n<a href=\"https://ionos.adochub.com/\">ionos</a>\n<a href=\"https://thingsboard.adochub.com/\">thingsboard</a>\n<a href=\"https://openshift.adochub.com/\">openshift</a>\n<a href=\"https://anboxloud.adochub.com/\">anbox cloud</a>\n<a href=\"https://cloudera.adochub.com/\">cloudera</a>\n<a href=\"https://banzaicloud.adochub.com/\">banzaicloud</a>\n<a href=\"https://confluent.adochub.com/\">confluent</a>\n<a href=\"https://serverless.adochub.com/\">serverless</a>\n<a href=\"https://hashicorploud.adochub.com/\">hashicorp cloud</a>\n<a href=\"https://bitcoin.adochub.com/\">bitcoin</a>\n<a href=\"https://behat.adochub.com/\">behat</a>\n<a href=\"https://blender.adochub.com/\">blender</a>\n<a href=\"https://boost.adochub.com/\">boost</a>\n<a href=\"https://bosun.adochub.com/\">bosun</a>\n<a href=\"https://boto3.adochub.com/\">boto3</a>\n<a href=\"https://centos.adochub.com/\">centos</a>\n<a href=\"https://cherrypy.adochub.com/\">cherrypy</a>\n<a href=\"https://ckeditor.adochub.com/\">ckeditor</a>\n<a href=\"https://platformio.adochub.com/\">platformio</a>\n<a href=\"https://cloudkit.adochub.com/\">cloudkit</a>\n<a href=\"https://cocoapods.adochub.com/\">cocoapods</a>\n<a href=\"https://cocos2d-x.adochub.com/\">cocos2d-x</a>\n<a href=\"https://elementscompiler.adochub.com/\">elementscompiler</a>\n<a href=\"https://couchbase.adochub.com/\">couchbase</a>\n<a href=\"https://cython.adochub.com/\">cython</a>\n<a href=\"https://debian.adochub.com/\">debian</a>\n<a href=\"https://eclipse.adochub.com/\">eclipse</a>\n<a href=\"https://extjs.adochub.com/\">extjs</a>\n<a href=\"https://ffmpeg.adochub.com/\">ffmpeg</a>\n<a href=\"https://claris.adochub.com/\">claris</a>\n<a href=\"https://firebirdsql.adochub.com/\">firebirdsql</a>\n<a href=\"https://themegrill.adochub.com/\">themegrill</a>\n<a href=\"https://flexbox.adochub.com/\">flexbox</a>\n<a href=\"https://freebsd.adochub.com/\">freebsd</a>\n<a href=\"https://gulpjs.adochub.com/\">gulpjs</a>\n<a href=\"https://tutorialspoint.adochub.com/\">tutorialspoint</a>\n<a href=\"https://www.wikihow.com/Main-Page\">wikihow</a>\n<a href=\"https://geeksforgeeks.adochub.com/\">geeksforgeeks</a>\n<a href=\"https://heroku.adochub.com/\">heroku</a>\n<a href=\"https://hibernate.adochub.com/\">hibernate</a>\n<a href=\"https://highcharts.adochub.com/\">highcharts</a>\n<a href=\"https://jenkins.adochub.com/\">jenkins</a>\n<a href=\"https://neo4j.adochub.com/\">neo4j</a>\n<a href=\"https://nunit.adochub.com/\">nunit</a>\n<a href=\"https://odoo.adochub.com/\">odoo</a>\n<a href=\"https://opencv.adochub.com/\">opencv</a>\n<a href=\"https://opengl.adochub.com/\">opengl</a>\n<a href=\"https://openlayers.adochub.com/\">openlayers</a>\n<a href=\"https://openstreetmap.adochub.com/\">openstreetmap</a>\n<a href=\"https://openssl.adochub.com/\">openssl</a>\n<a href=\"https://osgi.adochub.com/\">osgi</a>\n<a href=\"https://phantomjs.adochub.com/\">phantomjs</a>\n<a href=\"https://pharo.adochub.com/\">pharo</a>\n<a href=\"https://playframework.adochub.com/\">playframework</a>\n<a href=\"https://postman.adochub.com/\">postman</a>\n<a href=\"https://poweri.adochub.com/\">power bi</a>\n<a href=\"https://shopify.adochub.com/\">shopify</a>\n<a href=\"https://sinatra.adochub.com/\">sinatra</a>\n<a href=\"https://slf4j.adochub.com/\">slf4j</a>\n<a href=\"https://spotify.adochub.com/\">spotify</a>\n<a href=\"https://swagger.adochub.com/\">swagger</a>\n<a href=\"https://swig.adochub.com/\">swig</a>\n<a href=\"https://javatpoint.adochub.com/\">javatpoint</a>\n<a href=\"https://tableau.adochub.com/\">tableau</a>\n<a href=\"https://telegram.adochub.com/\">telegram</a>\n<a href=\"https://testNG.adochub.com/\">testNG</a>\n<a href=\"https://tornado.adochub.com/\">tornado</a>\n<a href=\"https://vaadin.adochub.com/\">vaadin</a>\n<a href=\"https://varnish.adochub.com/\">varnish</a>\n<a href=\"https://virtualbox.adochub.com/\">virtualbox</a>\n<a href=\"https://woocommerce.adochub.com/\">woocommerce</a>\n<a href=\"https://grammarly.adochub.com/\">grammarly</a>\n<a href=\"https://zeromq.adochub.com/\">zeromq</a>\n<a href=\"https://flutterflow.adochub.com/\">flutterflow</a>\n<a href=\"https://getwidget.adochub.com/\">getwidget</a>\n<a href=\"https://sentry.adochub.com/\">sentry</a>\n<a href=\"https://unrealengine.adochub.com/\">unreal engine</a>\n<a href=\"https://scandit.adochub.com/\">scandit</a>\n<a href=\"https://praw.adochub.com/\">praw</a>\n<a href=\"https://airship.adochub.com/\">airship</a>\n<a href=\"https://flameengine.adochub.com/\">flame engine</a>\n<a href=\"https://sectionio.adochub.com/\">section io</a>\n<a href=\"https://appium.adochub.com/\">appium</a>\n<a href=\"https://scipy.adochub.com/\">scipy</a>\n<a href=\"https://kivy.adochub.com/\">kivy</a>\n<a href=\"https://jupyter.adochub.com/\">jupyter</a>\n<a href=\"https://selenium.adochub.com/\">selenium</a>\n<a href=\"https://kommunicate.adochub.com/\">kommunicate</a>\n<a href=\"https://botsquad.adochub.com/\">botsquad</a>\n<a href=\"https://wireshark.adochub.com/\">wireshark</a>\n<a href=\"https://ovh.adochub.com/\">ovh</a>\n<a href=\"https://openebs.adochub.com/\">openebs</a>\n<a href=\"https://mayastor.adochub.com/\">mayastor</a>\n<a href=\"https://clickhouse.adochub.com/\">clickhouse</a></p>\n</div>",
		"title": "史上最全的文档地址列表",
		"last_reply_at": "2022-05-22T08:50:39.503Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 71,
		"create_at": "2022-05-22T08:50:39.503Z",
		"author": {
			"loginname": "fengmao",
			"avatar_url": "https://avatars.githubusercontent.com/u/30584594?v=4&s=120"
		}
	}, {
		"id": "53b93bab1b009b31532ef934",
		"author_id": "50f7a0a9df9e9fcc5889a1b0",
		"content": "<div class=\"markdown-text\"><p>要安全的, 要用gmail.\n封这么厉害…</p>\n</div>",
		"title": "有靠谱的VPN推荐吗?",
		"last_reply_at": "2022-05-20T07:54:09.446Z",
		"good": false,
		"top": false,
		"reply_count": 84,
		"visit_count": 223942,
		"create_at": "2014-07-06T12:06:03.451Z",
		"author": {
			"loginname": "ronincn",
			"avatar_url": "//gravatar.com/avatar/0582e15ee13a3fef9d78dac6f0c71575?size=48"
		}
	}, {
		"id": "545249abd0c2f0fe2f533ad6",
		"author_id": "544475344ca29a4d4c08c331",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>rt</p>\n</div>",
		"title": "请教大神们，都怎么实现‘科学上网’撒",
		"last_reply_at": "2022-05-20T07:54:00.642Z",
		"good": false,
		"top": false,
		"reply_count": 29,
		"visit_count": 16958,
		"create_at": "2014-10-30T14:22:35.923Z",
		"author": {
			"loginname": "iamnotblank",
			"avatar_url": "https://avatars1.githubusercontent.com/u/6949176?v=4&s=120"
		}
	}, {
		"id": "575c0f3a2ad3c06f1aa3d5ed",
		"author_id": "56cd160ac045c3743304beec",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><ul>\n<li>别用国内付费VPN服务，<strong>Green就是教训</strong>。</li>\n<li>别想着“免费”，能用的付费vpn得花钱，不便宜，<strong>便宜的根本没法用</strong>，几十块一年的等于智商税。</li>\n<li><strong>没有100%稳定高速的服务</strong>，特殊时段，即使付费vpn也不能总是“高速稳定”，别指望一年365天一天24小时随时1080p油管。</li>\n<li>一线国外付费VPN能保证的是“<strong>较好</strong>”的连通率和速度，不完美，但至少能用google，gmail和可接受的油管速度，这仍是目前最好的方案。</li>\n</ul>\n<p><strong>国内还能用支付宝买到</strong>的国外付费vpn推荐：</p>\n<h2>ExpressVPN</h2>\n<p>全球148+服务器所在地 / 无限流量 / 多协议，包括openVPN / 一键连接 / 同时3台设备 / 256-bit AES加密 / 支付宝支付 / 支持路由器连接 / 完全IP隐藏 / 零日志 / 全终端覆盖 / 30天无条件退款 / Split tunneling技术 + 浏览器插件，同时访问内外网 / <strong>速度相对最快</strong></p>\n<h2>熊猫VPN</h2>\n<p><code>缺点：运营时间还比较短，只支持同时3个连接，且不支持路由器和Linux，缺乏自动重连等职能功能。</code></p>\n<p>VPN的后起之秀，正在促销，<strong>买一年送一年</strong>，服务器亲测可用，而且很快。产品运营时间还不长，处于推广阶段，价格优惠幅度很大。</p>\n<p>支持Windows，Mac，iOS，Android客户端。连接VPN只需要一个开关即可。界面极其简洁，同时3台设备，这是一个让人惊喜的发现，支持智能分流。</p>\n<p><strong>虽然熊猫VPN远没有ExpressVPN强大，如客户端支持远没有ExpressVPN丰富，同时也只支持3个连接，官方也不披露日志政策</strong>，但对不少人也应该日常够用。从客户端来看，熊猫VPN背后可能不是VPN翻墙技术，而是用了类似SSR的某种加密代理，这无法确定，但是能用最重要。</p>\n<h2>VyprVPN</h2>\n<p>70+自有服务器所在地，200,000+IP地址 / 无限流量 / 多协议，独家混淆协议 / 一键连接 / 同时5台设备 / 支持P2P / 变色龙加密，<strong>连接相对最稳定</strong> / 支付宝支付 / 支持路由器连接 / NAT安全机制 / DNS加密 / 全终端覆盖 / 2年款最大优惠 / 30天无条件退款 / 按程序控制网络技术，同时访问内外网</p>\n</div>",
		"title": "稳定的付费vpn推荐",
		"last_reply_at": "2022-05-20T07:53:56.268Z",
		"good": false,
		"top": false,
		"reply_count": 21,
		"visit_count": 31944,
		"create_at": "2016-06-11T13:16:42.992Z",
		"author": {
			"loginname": "flamingtop",
			"avatar_url": "https://avatars3.githubusercontent.com/u/132677?v=4&s=120"
		}
	}, {
		"id": "5514b132e26684ed7ff21bf2",
		"author_id": "53fdd8502243147e7857b2bb",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>发现一堆网站上不了\n你们都用什么 VPN? 推荐下\n以前到 V2EX 查，发现 V2EX 也上不了\n免费的付费的都行</p>\n</div>",
		"title": "你用什么 VPN?",
		"last_reply_at": "2022-05-20T07:53:49.970Z",
		"good": false,
		"top": false,
		"reply_count": 64,
		"visit_count": 41395,
		"create_at": "2015-03-27T01:24:02.838Z",
		"author": {
			"loginname": "russj",
			"avatar_url": "https://avatars2.githubusercontent.com/u/2281763?v=4&s=120"
		}
	}, {
		"id": "593d631a325c502917ef0881",
		"author_id": "541878e05f67e2b8570e1c65",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>最近有墙外网站爬虫需求，做了个demo发现node的http/request等模块一旦请求墙外站点，就会返回“connect refused”之类的提示。要么就是timeout。换回墙内站点就各种没问题。</p>\n<p>我翻墙是用shadowsocks，不知道是不是这个只能解决浏览器翻墙问题。</p>\n<p>有没有大神可以指点一下接下来应该怎么做，有点迷茫</p>\n</div>",
		"title": "翻墙后无法node请求墙外站点",
		"last_reply_at": "2022-05-20T07:53:42.830Z",
		"good": false,
		"top": false,
		"reply_count": 21,
		"visit_count": 10542,
		"create_at": "2017-06-11T15:34:50.921Z",
		"author": {
			"loginname": "backlost",
			"avatar_url": "https://avatars0.githubusercontent.com/u/4522159?v=4&s=120"
		}
	}, {
		"id": "6216007665073ac38c32e32d",
		"author_id": "5d47c83b4f472f7fee152927",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>我知道市面上已经有好多好多通知组件了<br>\n但我还是写了一个，实用倒是其次，主要是好玩<br>\n欢迎大家来看一看，<a href=\"https://ppz-pro.github.io/noty.js/docs/\">传送门 https://ppz-pro.github.io/noty.js/docs/</a><br>\n以码会友~~~</p>\n<p>除了默认的丝滑的（我觉得还算丝滑）入场、出场动画<br>\n这个新的通知组件，提供了较深度的定制方案<br>\n你可以从“<strong>出入场</strong>动画”和“通知UI”两方面定制</p>\n<p>noty.js 通过 Proxy 把这两个业务剥离开来，可进行自由组合</p>\n<p>另外，noty.js 非常简洁（核心代码 41 行）</p>\n</div>",
		"title": "[noty.js] 沉迷造轮子，无法自拔！又写了一个通知组件~",
		"last_reply_at": "2022-05-20T03:13:14.140Z",
		"good": false,
		"top": false,
		"reply_count": 9,
		"visit_count": 21086,
		"create_at": "2022-02-23T09:37:58.059Z",
		"author": {
			"loginname": "daGaiGuanYu",
			"avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
		}
	}, {
		"id": "628335bd79f90dfe25a0e462",
		"author_id": "6056dfd7dac5420eb5e289b0",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>写node的最大感受就是，不断地用脚本在写路由，用了框架也是如此，本来这些属于服务器的任务，结果变成了脚本的任务，令人厌倦，实在烦了，难怪创始人都走了。\n如果asp开源，独立出iis，支持跨平台、js新特性，吸收node，php，.net，Java，ruby等技术的优点，不断升级，成为一个轻量级的技术。那么，会果断把node给扔了，不再用这玩意。可惜了asp。\n现在，把node的各种包，加上node本身，整个体积和php差不多，越来越臃肿。\n如果node官方，能改改，把路由变成exe里的一部分，成为类似apache、tomcat的东西，接管路由，不再是现在一个路由文件负责。或者变成双模式，由config。xml，或config。json进行一下配置，可以延续原有的路由模式，或者象其他语言的一样，由服务器接管，那就好了。有个选择，总比没有要好太多。</p>\n<p>设想：</p>\n<p>1，设置根目录下的 config.json 或 server.json，发挥基础作用</p>\n<p>2，后缀改变，。njs 取代 。js，直接废掉静态目录设定</p>\n<p>由于要废掉静态目录设置，所以有必要区分 js\n。njs 给 node 的，只能后端执行，动态文件\n。js 是给前端的，只能前端执行，静态文件</p>\n<p>njs 是默认后缀，也可以在前面的json配置中，改为任意名称</p>\n<p>3，单入口模式终结，保留单入口模式，增加多入口模式，也就是 exe 接管路由\nserve。json里设置采用什么模式\n单入口模式，假设叫特殊模式，启动采用：node 入口\n多入口模式，假设叫常规模式，由 node。exe 接管路由，有更大权力\n启动时，直接根目录下：\nnode 或 node .\n自动加载 。json 配置\n抛弃以前的单入口路由模式。</p>\n<p>常规模式下，所有的 。njs 都会被直接执行。</p>\n<p>4，config.json 或 server.json，设置路径作用</p>\n<p>在 json中可以设置访问路径\n{\n// 虚拟路径 》实际路径\n虚拟路径：实际路径，\n// 或者 虚拟路径 》虚拟路径 》实际路径\n虚拟路径：{\n\t\t虚拟路径： 实际路径\n\t},\n// 或者 虚拟路径 》实际路径 》实际路径\n虚拟路径：{\n\t\t实际路径： 实际路径\n\t}\n}\n废掉 express 等框架</p>\n<p>5，url的访问，默认是同名 njs\n如：\nhttp：//url/list\n实际访问 list。njs</p>\n<p>如果设置了虚拟路径，则 json配置的虚拟路径生效，更高优先级。</p>\n<p>如果访问目录\nhttp：//url/list/\n默认访问 list/ 目录下的 index。njs</p>\n<p>可以在前面的 json 配置文件设置影响所有目录的默认访问文件，也可以单独为不同目录设置不同的首个默认文件。\n如果不设置，默认为 index。njs</p>\n<p>6，node作为服务器的安全提升，无需第三方工具以防宕机</p>\n<p>7，依然使用 js，而不用 ts</p>\n<p>8，以上的设想，不是再用 js 写个新的框架，而是用 C和C++从底层彻底改变 node。exe</p>\n</div>",
		"title": "Node真该改改了",
		"last_reply_at": "2022-05-19T06:26:44.698Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 571,
		"create_at": "2022-05-17T05:42:21.693Z",
		"author": {
			"loginname": "enzh",
			"avatar_url": "https://avatars.githubusercontent.com/u/75319168?v=4&s=120"
		}
	}, {
		"id": "62829f7079f90df8b0a0e40b",
		"author_id": "5a051be2ee9b35da75a869f7",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"https://user-images.githubusercontent.com/23253540/168573694-9b34aab7-a807-4d73-a420-d685e3acaace.png\" alt=\"image\">\n原文链接: <a href=\"https://github.com/xiaoxiaojx/blog/issues/35\">https://github.com/xiaoxiaojx/blog/issues/35</a></p>\n<h2>背景</h2>\n<p>单元测试节点失败了, 点进来查看发现是一个内部的 Node.js C++ 插件运行时报错了 ❌, 错误信息为: undefined symbol: _ZN3leo6AppEnv9swimlane_B5cxx11E。</p>\n<h2>symbol 的基本概念</h2>\n<p>在计算机中，一个函数的指令被存放在一段内存中，当进程需要执行这个函数的时候，它必须知道要去内存的哪个地方找到这个函数，然后执行它的指令。也就是说，进程要根据这个函数的名称，找到它在内存中的地址，而这个名称与地址的映射关系，是存储在 “symbol table”中。</p>\n<p>“symbol table”中的 symbol 就是这个函数的名称，进程会根据这个 symbol 找到它在内存中的地址，然后跳转过去执行。</p>\n<h2>问题分析</h2>\n<p>了解到 symbol 的概念后, 我们知道了 symbol 记录了变量在内存中的地址, 那么 undefined symbol 可能就是找不到该地址或者是非法不匹配的地址。</p>\n<p>先查阅一下 <a href=\"https://www.shuzhiduo.com/A/KE5QNjLydL/\">undefined symbol 可能的原因</a> 来指引一下接下来的排查方向</p>\n<ol>\n<li>\n<p>依赖库未找到</p>\n<ul>\n<li>这是最常见的原因，一般是没有指定查找目录，或者没有安装到系统查找目录里</li>\n</ul>\n</li>\n<li>\n<p>链接的依赖库不一致</p>\n<ul>\n<li>编译的时候使用了高版本，然后不同机器使用时链接的却是低版本，低版本可能缺失某些 api</li>\n</ul>\n</li>\n<li>\n<p>符号被隐藏</p>\n<ul>\n<li>如果动态库编译时被默认隐藏，外部代码使用了某个被隐藏的符号。</li>\n</ul>\n</li>\n<li>\n<p>c++ abi 版本不一致</p>\n<ul>\n<li>最典型的例子就是 gcc 4.x 到 gcc 5.x 版本之间的问题，在 4.x 编辑的动态库，不能在 5.x 中链接使用。</li>\n</ul>\n</li>\n</ol>\n<h2>问题排查</h2>\n<p>首先拉取出现问题的镜像开始本地复现问题, 然后使用 nm 命令来显示更多查找 symbol 时具体的信息</p>\n<blockquote>\n<p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html\">linux nm 命令</a> 显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库.</p>\n</blockquote>\n<p>本地也顺利复现了该问题</p>\n<pre class=\"prettyprint\"><code>undefined symbol: _ZN3leo6AppEnv9swimlane_B5cxx11E\n</code></pre><p>接着我们运行 nm 命令来查看详细信息</p>\n<pre class=\"prettyprint language-bash\"><code>nm -D &#x2F;xxx&#x2F;build&#x2F;Release&#x2F;leo_client.node\n</code></pre><p>下面是截取的 nm 的输出日志, 可以看到 _ZN3leo6AppEnv9swimlane_B5cxx11E 的地址是缺失的</p>\n<pre class=\"prettyprint language-bash\"><code>                 U _ZN3leo6AppEnv9swimlane_B5cxx11E\n0000000000661c80 B _ZN3leo6AppEnv9swimlane_E\n000000000026f34c W _ZN3leo6LeoKeyaSEOS0_\n000000000026f6e0 W _ZN3leo6LeoKeyC1EOS0_\n000000000026e3e2 W _ZN3leo6LeoKeyC1ERKS0_\n000000000032eafc T _ZN3leo6LeoKeyC1ERKSs\n000000000026e1d4 W _ZN3leo6LeoKeyC1ERKSsS2_\n000000000026e188 W _ZN3leo6LeoKeyC1Ev\n000000000026f6e0 W _ZN3leo6LeoKeyC2EOS0_\n000000000026e3e2 W _ZN3leo6LeoKeyC2ERKS0_\n</code></pre><p>这些日志还不能让我们准确定位到源码, 接着继续加了 c++filt 命令来还原 C++ 编译后的函数名</p>\n<blockquote>\n<p><a href=\"https://man7.org/linux/man-pages/man1/c++filt.1.html\">c++filt(1) — Linux manual page</a>  C++ 和 Java 语言提供函数重载， 意味着您可以编写许多具有相同名称的函数， 前提是每个函数都采用不同类型的参数。 为了能够区分这些同名的 函数 C++ 和 Java 将它们编码为低级汇编程序 唯一标识每个不同版本的名称。这 过程称为重整。 c++filt 程序执行 逆映射：它将低级名称解码（解码）成 用户级别的名称，以便它们可以被读取。</p>\n</blockquote>\n<pre class=\"prettyprint language-bash\"><code>nm -D &#x2F;xxx&#x2F;build&#x2F;Release&#x2F;leo_client.node | c++filt\n</code></pre><p>此时的日志已经可以让我们定位到对应源代码, 而错误处多了关键的 [abi:cxx11] 的信息, 似乎对应了上面所说的第4点 c++ abi 版本不一致</p>\n<pre class=\"prettyprint language-bash\"><code>                 U leo::AppEnv::swimlane_[abi:cxx11]\n0000000000661c80 B leo::AppEnv::swimlane_\n000000000026f34c W leo::LeoKey::operator=(leo::LeoKey&amp;&amp;)\n000000000026f6e0 W leo::LeoKey::LeoKey(leo::LeoKey&amp;&amp;)\n000000000026e3e2 W leo::LeoKey::LeoKey(leo::LeoKey const&amp;)\n000000000032eafc T leo::LeoKey::LeoKey(std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)\n000000000026e1d4 W leo::LeoKey::LeoKey(std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)\n000000000026e188 W leo::LeoKey::LeoKey()\n000000000026f6e0 W leo::LeoKey::LeoKey(leo::LeoKey&amp;&amp;)\n000000000026e3e2 W leo::LeoKey::LeoKey(leo::LeoKey const&amp;)\n</code></pre><p>通过查看对应的源码找到了 swimlane_ 变量与其类型 std::string</p>\n<pre class=\"prettyprint language-c++\"><code>&#x2F;&#x2F; 报错的源码\n\nstatic std::string swimlane_;\n</code></pre><p>接着继续查阅 [abi:cxx11] 关键词相关的文档 <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html\">Dual ABI</a></p>\n<blockquote>\n<p>在 GCC 5.1 版本中，libstdc++ 引入了一个新库 ABI，其中包括std::string和 std::list. 为了符合 2011 C++ 标准，这些更改是必要的，该标准禁止 Copy-On-Write 字符串并要求列表跟踪其大小。</p>\n</blockquote>\n<blockquote>\n<p>为了保持与 libstdc++ 链接的现有代码的向后兼容性，库的 soname 没有更改，旧实现仍与新实现并行支持。这是通过在内联命名空间中定义新实现来实现的，因此它们具有不同的名称以用于链接目的，例如，新版本 std::list&lt;int&gt;实际上定义为 std::__cxx11::list&lt;int&gt;. 因为新实现的符号具有不同的名称，所以两个版本的定义可以存在于同一个库中。</p>\n</blockquote>\n<p>看到这里我们这里知道了 GCC 5.1 版本后实现了新的 std::string 定义为了 std::__cxx11::string, 同时也保留了旧版本的 std::string, 5.1 版本后可以自主选择使用哪个版本, 而 5.1 版本之前就固定是旧版本了。</p>\n<p>[abi:cxx11] 的报错则表明你正在尝试将使用不同版本编译的目标文件链接在一起, 当链接到使用旧版本 GCC 编译的第三方库时，通常会发生这种情况。如果第三方库不能用新的 ABI 重建，那么你需要用旧的 ABI 重新编译你的代码。</p>\n<p>由此也印证了之前分享的 <a href=\"https://github.com/xiaoxiaojx/blog/issues/22\">API 与 ABI 的区别</a> 提到的维持 API 稳定容易, ABI 稳定就涉及太多要素。</p>\n<blockquote>\n<p>_GLIBCXX_USE_CXX11_ABI 宏（请参阅宏）控制库头文件中的声明是使用旧 ABI 还是新 ABI。因此，可以为每个正在编译的源文件单独决定使用哪个 ABI。使用 GCC 的默认配置选项，宏的默认值为 1，这会导致新 ABI 处于活动状态，因此要使用旧 ABI，您必须在包含任何库头之前将宏显式定义为 0。 （请注意，某些 GNU/Linux 发行版对 GCC 5 的配置不同，因此宏的默认值为 0，用户必须将其定义为 1 才能启用新的 ABI。）</p>\n</blockquote>\n<h2>问题解决</h2>\n<p>由上可知可以通过设置 _GLIBCXX_USE_CXX11_ABI 宏的值 0 为关闭, 1 为开启来决定采用旧版还是新版\n。那我们的 Node.js C++ 插件如何设置这个宏的值了？</p>\n<p>该插件根目录的 binding.gyp 的 defines 字段即可, 此时可以通过设置 _GLIBCXX_USE_CXX11_ABI=0 和 _GLIBCXX_USE_CXX11_ABI=1 分别进行编译一次, 这样就知道当前插件应该是用新还是旧才能和其他链接库兼容了, 最后设置 _GLIBCXX_USE_CXX11_ABI=0 后本地通过源码重新编译就能成功运行了 ✅ 。</p>\n<pre class=\"prettyprint language-diff\"><code>- &#x27;defines&#x27;: [ &#x27;NAPI_DISABLE_CPP_EXCEPTIONS&#x27; ],\n+ &#x27;defines&#x27;: [ &#x27;NAPI_DISABLE_CPP_EXCEPTIONS&#x27;, &#x27;_GLIBCXX_USE_CXX11_ABI=0&#x27; ],\n</code></pre></div>",
		"title": "C++ addons undefined symbol 问题排查",
		"last_reply_at": "2022-05-16T19:01:04.283Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 268,
		"create_at": "2022-05-16T19:01:04.283Z",
		"author": {
			"loginname": "xiaoxiaojx",
			"avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
		}
	}, {
		"id": "627dee9e79f90d06c4a0e1ed",
		"author_id": "600958385d04ac8dfe217db8",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>BFF字面意思是服务于前端的后端，我的理解就是数据聚合层。我们组在维护一个后台管理系统，会频繁的与数据库交互。</p>\n<p>过去为了增删改查会写大量的对应接口，并且还需要在Model、Service、Router三层写不同的代码逻辑，吃力不讨好。</p>\n<p>为了节约开发时间，构思通用接口，并付诸于实际项目中。虽然简化了Router和Service部分，但其实就是将该部分的代码迁移到了前端页面中。</p>\n<p>这里有一点小隐患，因为目前我们组的成员是全栈维护，所以知道数据库ORM的语法规则，若前后端分离，那就不可取了，并且工作量其实是从后端转移到了前端。</p>\n<p>虽然时间是节约了一些，但是后端的代码却暴露在了前端，维护性方面下降了不少，于是想到了BFF。</p>\n<p>首先查看了许多已经在运行的成功案例，有些是基于GraphQL重新封装的系统，有些是定制化的系统。经过三天的仔细权衡对比后，决定自己定制化。</p>\n<p>主要考虑了两方面，一方面是改造成本，如果基于GraphQL的一些封装库（例如Type-GraphQL、apollo、Prisma等）来设计系统的话，那势必需要了解这些的库的方方面面，并且还需要将其集成到已经的结构中。</p>\n<p>另一方面是使用成本，系统完成后是给人用的，不能太复杂，为了避免让使用人员来适应这套系统，最方便的就是将之前的开发流程修改成配置化。</p>\n<p>BFF的实现逻辑由后端定义，并且⽆需重构，也不必后端配合改造与联调。</p>\n<p>这套系统完成后，会真真切切地影响之前的开发流程，例如不必单独写接口文档，并且可以随时在系统中调试，而不必借助postman调试。</p>\n<h3>一、前端界面</h3>\n<p><strong>1）配置</strong></p>\n<p>当前80%的Node接口代码复杂度都并不⾼，基本都是机械化重复的，这些接口可分为三部分：参数处理（1）、服务调用（2）和响应聚合（3），类似于下图。\n<img src=\"//static.cnodejs.org/FltTv7ORI7Latqo0Pm1ltG4uBTiJ\" alt=\"1.png\"></p>\n<p>那么前端界面就可以围绕这三部分展开，如下图所示，其中处理器就是服务调用，只是会基于通用接口服务和指定的Model的封装函数。\n<img src=\"//static.cnodejs.org/FmtLPgWgp6c6riECK2RWw9Wd1U2V\" alt=\"2.png\"></p>\n<p>权限ID就是一段字符串，会在权限系统做接口校验，具体会在后文讲解。模块其实就是之前Router目录中的各个文件，现在将它们作为选项存在。</p>\n<p>参数是可以动态配置的，处理器也是一样，并且在选中方法后会显示方法名和方法参数，而在选好Model文件后，会出现查看按钮。\n<img src=\"//static.cnodejs.org/Fm6dImmH2pQkqJERtXBA7JxdvI0z\" alt=\"3.png\"></p>\n<p>点击查看按钮就能看到Model文件中映射的属性，以及数据库表的字段了，在之前的开发中经常需要查找这些属性和字段，甚是繁琐。</p>\n<p>逻辑结构就是接口的主体，除了参数部分的代码不需要写之外，其余代码都在这里完成，是整个接口最为核心的部分。\n<img src=\"//static.cnodejs.org/Flz3lds3fjy9jwl0qhjy__oIb-s7\" alt=\"4.png\"></p>\n<p>这部分的处理我其实考虑了很久，在简便和自定义之间找到了一个平衡点，最终才实现了上述效果。</p>\n<p>之前声明的参数和处理器都可以在这个编辑器中引用，这个代码编辑器采用的是monaco-editor，微软出品的VS Code浏览器版本，该有的功能都有。</p>\n<p>但是我只集成了代码高亮的功能，自动索引的功能没有成功集成进来，顺便说下，官方的API文档非常不友好。</p>\n<p><strong>2）调试</strong></p>\n<p>在配置化界面的最下方，就是调试部分，当接口创建完成后，就能马上调试。\n<img src=\"//static.cnodejs.org/FlbdsdAjHsVGQBbdHiTKJH_LYL7y\" alt=\"5.png\"></p>\n<p>点击API文本框中的搜索icon，就能看到最终的源码了，能帮助自己迅速定位问题。\n<img src=\"//static.cnodejs.org/Fr63fbrL9whh11hroUTYemVy5t2x\" alt=\"6.png\"></p>\n<p><strong>3）列表</strong></p>\n<p>在列表界面中，包含新建的入口，以及查看和编辑。当跳转到创建页面后，点击浏览器的返回键，列表页面能恢复成之前的样子。\n<img src=\"//static.cnodejs.org/FnJ4XatqN99tLorS5zrMn1nBJEh_\" alt=\"7.png\"></p>\n<p>列表页面的状态不会受跳转的影响。点击查看会出现配置信息、源码和调试界面，这些配置信息就是接口文档，并且还能随时调试。\n<img src=\"//static.cnodejs.org/FiuSS1gVEakltUBnxa8BQ2tV-ywx\" alt=\"8.png\"></p>\n<h3>二、后端服务</h3>\n<p>这次我将API接口的数据都存储在MongoDB中，主要考虑的是数据中会包含大量的数组和JSON对象，若存在MySQL中，就需要在存入和取出时做序列化和反序列化。</p>\n<p><strong>1）vm</strong></p>\n<p>后端在接收到界面中的参数后，就会将相关参数解析成对应代码，再拼接成一整段的字符串代码。执行这段代码使用的是Node内置的vm模块。</p>\n<pre class=\"prettyprint language-javascript\"><code>const sandbox = {\n  ctx,\n  services,\n  console,\n  redis,\n  mainFunc: function () {}         &#x2F;&#x2F;主函数\n};\nvm.createContext(sandbox);\n&#x2F;&#x2F; 在执行上下文运行\nvm.runInContext(code, sandbox);\nawait sandbox.mainFunc();\n</code></pre><p>在sandbox变量中，特地声明了一个mainFunc属性，因为执行的代码中会使用await语法，那么就需要将代码包在由async声明的函数中。</p>\n<p><strong>2）接口调用</strong></p>\n<p>Node服务基于KOA框架，路由基于koa-router库，为了尽量与之前的调用方式保持一致，就重新声明了一个可配置的路由。</p>\n<pre class=\"prettyprint language-javascript\"><code>router.all(&quot;&#x2F;bff&#x2F;:path1&#x2F;:path2&quot;, async (ctx) =&gt; {\n  const { path1, path2 } = ctx.params;\n  const bff = await services.common.getOneBFF({ api: path1 + &quot;&#x2F;&quot; + path2 });\n  if (!bff) {\n    return;\n  }\n  &#x2F;&#x2F;权限判断\n  if (bff.authority) {\n    const pass = await checkAuth(ctx, bff.authority);\n    if (!pass) return;\n  }\n  &#x2F;&#x2F;运行代码\n  await runCode(bff.rawCode, ctx);\n});\n</code></pre><p>在这个方法中，配置了两个路径参数path1和path2，所有通过这套BFF系统创建的接口，在前端调用时，都需要添加 /bff/ 前缀。</p>\n<p>而权限判断都会交由 checkAuth() 函数处理，之前这个函数是一个中间件，那么将其关键部分抽象出来后，也能达到权限验证的效果，与普通接口无异。</p>\n</div>",
		"title": "基于 Node.js 自制 BFF",
		"last_reply_at": "2022-05-13T14:06:28.416Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 683,
		"create_at": "2022-05-13T05:37:34.613Z",
		"author": {
			"loginname": "pwstrick",
			"avatar_url": "https://avatars.githubusercontent.com/u/10544125?v=4&s=120"
		}
	}, {
		"id": "6205ed8da08b390c3c09c7d8",
		"author_id": "5c81f15090c14711cc8cb87e",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>NestJs目前周下载量已经达到120万了，用nestjs开发的人多吗？</p>\n<p><img src=\"//static.cnodejs.org/FglzZfP40wt2qMNLHx0aLSswMOwc\" alt=\"nestjs.jpg\"></p>\n</div>",
		"title": "NestJs目前周下载量已经达到120万了 用nestjs开发的人多吗",
		"last_reply_at": "2022-05-13T05:41:01.131Z",
		"good": false,
		"top": false,
		"reply_count": 16,
		"visit_count": 86706,
		"create_at": "2022-02-11T05:01:01.085Z",
		"author": {
			"loginname": "phonegap100",
			"avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
		}
	}, {
		"id": "627dce0b79f90d84efa0e19e",
		"author_id": "60460ff34655eaadc021a4db",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://tonzhon.com/import\">https://tonzhon.com/import</a></p>\n</div>",
		"title": "Tonzhon 现已支持导入外部歌单，是完整的。",
		"last_reply_at": "2022-05-13T03:18:35.743Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 339,
		"create_at": "2022-05-13T03:18:35.743Z",
		"author": {
			"loginname": "enzeberg",
			"avatar_url": "https://avatars.githubusercontent.com/u/18072932?v=4&s=120"
		}
	}, {
		"id": "627b86ad79f90d8449a0e03e",
		"author_id": "56f3854c0a5a2cfb3ad149e2",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>新版 <a href=\"https://github.com/avwo/whistle\">Whistle</a>（<code>v2.9.15+</code>）新增如下命令行功能**（目前只支持 Mac &amp; Windows 系统）**：</p>\n<ol>\n<li><code>w2 proxy</code>：设置系统代理</li>\n<li><code>w2 ca</code>：安装系统根证书</li>\n<li><code>w2 start --init</code>：启动（重启）Whistle 时设置系统代理和安装根证书</li>\n</ol>\n<p><strong>用途如下：</strong></p>\n<h1>一键安装 Whistle（Mac &amp; Windows）</h1>\n<blockquote>\n<p>如果没有安装 Node，请求先安装：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n</blockquote>\n<pre class=\"prettyprint language- sh\"><code>npm i -g whistle &amp;&amp; w2 start --init\n</code></pre><blockquote>\n<p>如果全局代理需要设置不代理的域名，可以采用：<code>npm i -g whistle &amp;&amp; w2 start --init &quot;domain1, domain2, *.domain&quot;</code></p>\n</blockquote>\n<p>上述命令分别为以下操作：</p>\n<ol>\n<li>安装 Whistle</li>\n<li>启动 Whistle ，同时设置系统代理（或不代理的白名单域名）及安装根证书</li>\n</ol>\n<p>设置代理及安装根证书时可能需要以下协助操作：</p>\n<h3>Mac</h3>\n<ol>\n<li>\n<p><strong>输入开机密码</strong>设置系统代理：\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f936fcc4743470fb35cf903c0960690~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pass.png\"></p>\n</li>\n<li>\n<p>**指纹验证（或输入开机密码）**安装根证书：</p>\n</li>\n</ol>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bfce8a596db4598a7154348a12f3ee4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-1652150957522.png\"></p>\n<h3>Windows</h3>\n<p>点击 “<strong>是(Y)</strong>” 按钮确定安装根证书：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95be230d2a2a4e3898d62a7b81db4ff4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"win.jpeg\"></p>\n<p>最后可以通过 Chrome 打开 Whistle 的管理界面（ <a href=\"http://local.whistlejs.com\">http://local.whistlejs.com</a> ）查看抓包及配置规则调试请求。</p>\n<h1>设置系统代理（w2 proxy）</h1>\n<ol>\n<li><code>w2 proxy</code>：设置系统代理 <code>127.0.0.1:port</code>，<code>port</code> 为当前系统运行的 Whistle 端口（如果没有取默认值 <code>8899</code>）</li>\n<li><code>w2 proxy 8080</code>：设置系统代理 <code>127.0.0.1:8080</code></li>\n<li><code>w2 proxy xxx.yyy.com:8080</code>：设置系统代理 <code>xxx.yyy.com:8080</code>（可以指向远程 Whistle、Nohost 等代理）</li>\n<li><code>w2 proxy xxx.yyy.com:8080 -x &quot;www.test.com, www.abc.com, *.xxx.com&quot;</code>：设置系统代理 <code>xxx.yyy.com:8080</code>，并设置不代理请求域名（<code>www.test.com, www.abc.com, *.xxx.com</code>）</li>\n<li><code>w2 proxy --off</code>：关闭系统代理</li>\n</ol>\n<h1>安装根证书（w2 ca）</h1>\n<ol>\n<li><code>w2 ca</code>：安装本地运行的 Whistle 实例根证书（自动检测当前运行的默认实例，如果没有取默认取 <code>8899</code> 端口）</li>\n<li><code>w2 ca 8888</code>：安装本地 <code>8888</code> 端口的 Whistle 根证书</li>\n<li><code>w2 ca xxx.yyy.com:8080</code>：安装运行在 <code>host</code> 和 <code>port</code> 的其它 Whistle 或 Nohost 的根证书</li>\n<li><code>w2 ca filepath</code>：安装本地文件 <code>filepath</code> 存储的根证书</li>\n<li><code>w2 ca url</code>：安装指定 url 存储的根证书</li>\n</ol>\n<p>了解更多内容请访问 GitHub ：<a href=\"https://github.com/avwo/whistle\">https://github.com/avwo/whistle</a></p>\n</div>",
		"title": "一键安装 Whistle",
		"last_reply_at": "2022-05-11T09:49:33.587Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 606,
		"create_at": "2022-05-11T09:49:33.587Z",
		"author": {
			"loginname": "avwo",
			"avatar_url": "https://avatars.githubusercontent.com/u/11450939?v=4&s=120"
		}
	}, {
		"id": "6246b4bed9954ebc927f9316",
		"author_id": "611393dca5d29dbb362d5eef",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FvwYqR0t_1G87W_FF7jEPh-iwGxF\" alt=\"2.jpeg\"></p>\n</div>",
		"title": "node开发太孤单了,建了个群,欢迎欢迎,共同学习交流(已更新入群二维码 )",
		"last_reply_at": "2022-05-09T06:03:45.942Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 35920,
		"create_at": "2022-04-01T08:15:58.486Z",
		"author": {
			"loginname": "huge689",
			"avatar_url": "https://avatars.githubusercontent.com/u/44516016?v=4&s=120"
		}
	}, {
		"id": "580a6a7e541dfb7b50f40a60",
		"author_id": "575eaa97c1518403160a45c4",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h3>I. 写在前面</h3>\n<p>Egg框架开源都快2个月了，嗯，本以为能看到一些讨论的，结果等了一个月完全没见到大家写点和这个相关的东西，加上官方文档实在是。。。\n回归正题，作为国内不错的互联网公司，而且据说也是国内最早开始在生产中使用Node的大佬，我觉得不管外界如何评价，阿里开源的东西还是值得学习下的，最近读了一些里面的实现代码，有一些思路还是很值得公司自己编写组织强约束的Node框架学习的，所以这里算是抛砖引玉，写个基本的controller、router、service、自定义middleware和第三方的koa 1.x插件如何转换应用到egg中来。\n本文基于的egg版本为v0.2.1。</p>\n<h3>II. Quick Start</h3>\n<p>Egg是一个强约束的Node框架，这也会其和Express/Koa最大的不同，后者对开发者相对宽松，主要体现在目录结构，编写方式等均可以自定义。\nEgg对目录结构等有一系列要求，幸运的是，虽然官方文档几乎是鸭蛋，但是Git上的官方人员还是很贴心的给我们送上了一个自动生成项目目录以及一些简单例子的方式，我们可以来看下：</p>\n<ul>\n<li>执行如下命令来安装egg-init，在*nix系统下有可能需要sudo权限：\n<ul>\n<li>npm install egg-init -g</li>\n</ul>\n</li>\n<li>执行如下命令生成egg项目框架：\n<ul>\n<li>egg-init —type simple eggache</li>\n</ul>\n</li>\n<li>执行如下命令进入生成的项目目录：\n<ul>\n<li>cd eggache</li>\n</ul>\n</li>\n<li>执行如下命令，安装项目依赖：\n<ul>\n<li>npm  install</li>\n</ul>\n</li>\n<li>执行如下命令，启动egg项目：\n<ul>\n<li>node index.js</li>\n</ul>\n</li>\n</ul>\n<p>好了，到这里egg的样例已经运行起来，我们可以在浏览器中访问：</p>\n<pre class=\"prettyprint\"><code>127.0.0.1:7001&#x2F;news\n</code></pre><p>来观察Hacker News的页面是否正常展现出来，如果页面正常展现，则表明安装成功。</p>\n<h3>III. 框架结构概述</h3>\n<p>用任意的IDE打开项目目录，可以看下大致的文件目录结构：</p>\n<ul>\n<li><strong>app</strong>：核心目录，controller文件夹、public静态资源文件夹，middle中间件文件夹，service数据处理组装文件夹、view层展现相关文件夹以及router.js路由文件都在此目录下，这里也是以后大家使用egg开发的主要场所。</li>\n<li><strong>config</strong>：核心目录，配置文件相关，其中config.default.js中存放的是和当前Node环境无关的配置；config.[env].js文件则存放和Node执行环境相关的配置；plugin.js存放的则是各个插件的package名称和是否开启的配置。这里的Node执行环境，后面会说明。</li>\n<li><strong>logs</strong>：日志文件输出的目录。</li>\n<li><strong>index.js</strong>：项目的入口文件。</li>\n</ul>\n<p>这里大致介绍了下Egg框架的组成结构，后面会对两个核心目录app目录和config目录以及入口文件index.js文件的编写方式一一做介绍。</p>\n<h3>IV. index.js入口文件</h3>\n<p>我们从简单的地方开始介绍，首先是Egg框架的入口：index.js，当然文件名随意命名，这里使用的是II节中生成的官方样例。项目启动函数非常简单：</p>\n<pre class=\"prettyprint\"><code>require(&#x27;egg&#x27;).startCluster({\n\tbaseDir: __dirname,\n\tport: 7001, \n\tworkers: 1, &#x2F;&#x2F; default to cpu count\n});\n</code></pre><p>可以看到，启动文件中引入egg包后调用其startCluster函数，并且传入参数就可以了。实际上经过源码分析，这里面的可以传入的参数完整的是这样的：</p>\n<pre class=\"prettyprint\"><code>{\n\tcustomEgg: &#x27;&#x27;,\n\tbaseDir: process.cwd(),\n\tport: options.https ? 8443 : 7001,\n\tworkers: null,\n\tplugins: null,\n\thttps: false,\n \tkey: &#x27;&#x27;,\n\tcert: &#x27;&#x27;,\n}\n</code></pre><p>我们来逐个解析下：</p>\n<ul>\n<li><strong>customEgg</strong>：可选，指egg包所在的目录全路径，这个值框架默认会自动寻找填入。</li>\n<li><strong>baseDir</strong>：必选，执行egg框架所在的目录全路径，否则采用Node的启动路径。</li>\n<li><strong>port</strong>：必选，进程的端口号，默认https为8443，http为7001。</li>\n<li><strong>workers</strong>：可选，启动的子进程个数，默认和当前机器的cpu核数一致。</li>\n<li><strong>plugins</strong>：可选，插件的配置，如果填写必须填写插件配置的JSON字符串。</li>\n<li><strong>https</strong>：可选，默认为false。</li>\n<li><strong>key和cert</strong>：如果选择了https为true，则必选，必须填写可用证书路径。</li>\n</ul>\n<h3>V. config目录</h3>\n<h4>一. config.default.js</h4>\n<p>这个文件主要是用来存放项目所需要的和Node执行环境无关的配置，比如你定义的项目中的一些常量，可以写到config.default.js中。这里关于Node执行环境详细的说明可以参看本节的ENV相关说明。\n这个文件编写方式有两种模式，第一种是官方的示例：</p>\n<pre class=\"prettyprint\"><code>module.exports = appInfo=&gt;{\n\treturn {\n\t\t&#x2F;&#x2F;你需要添加的项目配置，下面是例子\n\t\tNAME:”EGG_ACHE”\n\t}\n}\n</code></pre><p>可以发现，这个和我们一般编写的配置文件不一样，它exports出来的是一个匿名函数，并且该函数有一个参数appInfo，那么这个appInfo是什么呢？\n经过查看egg的源代码（此处忍不住吐槽，0文档看起来真是累…），发现appInfo是Egg框架在自动加载配置文件时传入的一个对象，该对象结构如下：</p>\n<pre class=\"prettyprint\"><code>{\n        name: xxx,\n        baseDir: xxx,\n        env: xxx,\n        HOME: xxx,\n        pkg: xxx,\n}\n</code></pre><p>逐个关键字来说明：</p>\n<ul>\n<li><strong>name</strong>：项目的名称，也就是你的项目主目录的package.json中的name属性对应的值</li>\n<li><strong>baseDir</strong>：项目主目录所在的全路径</li>\n<li><strong>env</strong>：项目启动时配置的环境变量，具体参看本节后面的ENV相关说明</li>\n<li><strong>HOME</strong>：项目启动用户的根路径，process.env.HOME的值，是Node自动生成的</li>\n<li><strong>pkg</strong>：项目的package.json文件读取后得到的JSON对象</li>\n</ul>\n<p>好吧，吐槽归吐槽，从这里可以看到设计团队想的比较周到，有了这个我们在写配置文件时可以方便的调用这些传入的参数了。\n第二种就比较简单了，和普通的配置文件一样，直接使用exports或者module.exports将配置变量返回出来就行了。\nEgg框架在配置文件的处理上比较强大，会自动判断是否为函数，如果是函数则会传入appInfo后执行。</p>\n<h4>二. config.${env}.js</h4>\n<p>这个文件则主要是用来存放项目中和环境相关的一些配置，比如在local下的接口A地址\n配置为：<a href=\"http://a.org\">http://a.org</a>，在production下的接口A地址配置为：<a href=\"http://b.org\">http://b.org</a>，那么对于接口的A的地址配置来说，就需要分别写到config.local.js和config.production.js中。\n该文件的配置内容写法和上一小节中的config.default.js写法完全一致，同样提供了两种配置文件的写法，关于Node环境相关更详细的可以看本节后面的ENV相关说明。</p>\n<h4>三. ENV相关配置文件命名</h4>\n<p>EGG中上述的Node环境，即ENV参数，是用来区分开发/测试/线上的不同配置的，经过查看代码，egg提供的三种环境配置的名称分别为：</p>\n<ul>\n<li><strong>local</strong>：本地开发环境</li>\n<li><strong>unittest</strong>：单元测试环境</li>\n<li><strong>production</strong>：线上生产环境</li>\n</ul>\n<p>所以我们在config目录下的环境相关的配置文件可以命名为：config.local.js/config.unittest.js/config.production.js。\n这些和env相关的配置文件，会在启动时和config.default.js，由egg依据当前运行设置的env自动merge成一个全局config。</p>\n<h4>四. ENV的设置</h4>\n<p>经过查看egg的源代码，可以看到egg框架的env可以采用三种不同的方式进行设置：</p>\n<ul>\n<li>项目主目录的config文件夹下新建serverEnv，注意该文件没有.js等后缀！然后将上述的local/unittest/production填写进去即可。</li>\n<li>读取process.env.EGG_SERVER_ENV的值，这种方式需要启动前加上env前缀，例如：EGG_SERVER_ENV=‘local’ node index.js。其实这种是正式部署应用比较推荐的环境变量设置方式。</li>\n<li>兼容+默认的做法，因为好多公司Node开发使用的env变量名称为NODE_ENV，所以egg判断process.env.NODE_ENV的值为test的话，则ENV更新为unittest；如果process.env.NODE_ENV的值为production的话，则ENV更新为default（？这个相当无厘头，我怀疑是代码写错了，看里面的config加载机制，config.defaule.js是一定会加载的，存储的也是和环境无关的配置）；如果都不是，则更新当前的ENV为local。</li>\n</ul>\n<h3>VI. app目录</h3>\n<p>好了，前面的铺垫全部说完了，我们来看下最重要的app目录，以及如何编写app目录下的相关文件。</p>\n<h4>一. app目录结构概览</h4>\n<p>app目录下又按照设计模式分为了数个更细粒度的子目录，如下：</p>\n<ul>\n<li><strong>controller</strong>：存放controller层的处理文件的位置</li>\n<li><strong>extend</strong>：存放继承一些自定义公共方法的位置，这个在本节的下面详细说下</li>\n<li><strong>middleware</strong>：存放自定义中间件文件，所谓的appMiddleware</li>\n<li><strong>public</strong>：存放项目静态资源的位置</li>\n<li><strong>service</strong>：Egg框架抽象出来的一个概念，可以认为是带有逻辑处理的model层</li>\n<li><strong>view</strong>：存放页面模板文件的位置</li>\n<li><strong>router.js</strong>：编写路由的位置</li>\n</ul>\n<p>文件结构大致描述了下，下面我们逐个目录的分析里面的文件的作用以及如何来编写。</p>\n<h4>二. Egg中隐藏的app实例</h4>\n<p>在讲解下面的目录结构时，我们必须首先弄清一个概念，那就是Egg框架中实际上有一个核心的app实例，地位和Koa以及Express中的app一致，但是我们在Egg框架中无法像Koa/Express那样直接获取到这个app（app 实例是可以拿到的, 在根目录写个 app.js module.export = app =&gt; {}，框架支持这样使用app）。\n我们来看下这个核心的app如何生成：</p>\n<pre class=\"prettyprint\"><code>const Application = require(options.customEgg).Application;\nconst app = new Application({\n\tbaseDir: options.baseDir,\n\tplugins: options.plugins,\n});\n</code></pre><p>本文不对这个Application类详细展开，我们只需要知道，这个Application最终继承自Koa，同时Egg框架重载了Koa中的createContext函数，熟悉Koa 1.x源码的朋友都知道，这个createContext函数返回的ctx即为所有中间件中的this对象。由于Egg中重载后的ctx其原型指向的是app.context，所以只要在app.context上的所有函数，均可以在所有中间件（包含路由处理函数）中使用this来直接调用。\n为什么要特意说明下这个app呢，因为extend下的所有属性最终都会被框架自动挂载到app以及app.request/app.response/app.context/app.Helper.prototype上去。不理解这一点，就会很难理解中间件路由中的this对象和extend目录下的内容。</p>\n<h4>三. app/controller</h4>\n<p>这个目录下文件的概念和express以及koa的基本一致，就是路由调度的处理函数，如果文件仅仅想导出一个函数，编写方式如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = function *myHelloController() {\n\tthis.body = &#x27;Hello My First Egg Page!&#x27;;\n};\n</code></pre><p>由于整个Egg是基于koa 1.x开发的，所以这里做过koa 1.x项目的开发的小伙伴就会很熟悉，和koa 1.x的路由处理函数写法完全一致。\n如果controller下的一个js文件想导出多个路由处理函数，编写方式如下：</p>\n<pre class=\"prettyprint\"><code>exports.funcA = funtion * (){}\nexports.funcB = funtion * (){}\n…\n</code></pre><p>controller函数里面的this在上面的二节已经说明了，其行为基本和koa1.x一致。\n最后，Egg框架会自动将你编写的controller函数挂载到app.controller属性下，挂载的格式为：key是app/controller目录下的文件名进行小驼峰转换为，value是导出的内容，以II节中官方示例为例，其app/controller下的home.js和news.js挂在后为：</p>\n<pre class=\"prettyprint\"><code>app.controller = {   \n\thome: [Function: homeController],\n\t\tnews:{ \n\t\tlist: [Function: newsListController],\n    \t\tdetail: [Function: newsDetailController],\n    \t\tuser: [Function: userInfoController] \n\t\t} \n}\n</code></pre><p>如果我们再命名一个文件叫做my_hello.js，内容就是本小节开头写的路由函数，则得到的挂在后的app.controller为：</p>\n<pre class=\"prettyprint\"><code>app.controller = {   \n\thome: [Function: homeController],\n\t\tnews:{ \n\t\tlist: [Function: newsListController],\n    \t\tdetail: [Function: newsDetailController],\n    \t\tuser: [Function: userInfoController] \n\t\t} ,\n\tmyHello: [Function: myHelloController]\n}\n</code></pre><p>看到没，my_hello.js这种风格的会自动被转换为小驼峰形式的名称！\n那么到了这里，我们已经明白了如何编写路由文件，以及知道我们所编写的路由文件最后会被挂载到app.controller属性下。</p>\n<h4>四. app/extend</h4>\n<p>对于app/extend目录下的内容，如果理解了本大节的第二小节，就比较容易看懂了。app/extend下存在的对应文件分为5类，分别挂载到app的不同属性下：</p>\n<ul>\n<li><strong>app/extend/application.js</strong>：其导出的对象直接merge到app对象上</li>\n<li><strong>app/extend/request.js</strong>：其导出的对象直接merge到app.request对象上</li>\n<li><strong>app/extend/response.js</strong>：其导出的对象直接merge到app.response对象上</li>\n<li><strong>app/extend/context.js</strong>：其导出的对象直接merge到app.context对象上</li>\n<li><strong>app/extend/helper.js</strong>：其导出的对象直接merge到app.Helper.prototype原型上，作为原型app.Helper这个类的原型方法。</li>\n</ul>\n<p>这里的1，2，3三个基本上普通开发者无需编写，对于第四点来说，context.js的内容由于最后会merge到app.context中，所以我们如果想在自定义中间件/路由处理函数中的提供一些公共方法，可以直接写到context.js中，然后在自定义中间件/路由处理函数中使用this直接调用，举个例子，context.js内容如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n\tgetAche(){\n    \treturn &#x27;EGGACHE&#x27;;\n\t}\n};\n</code></pre><p>那么，我们在所有的中间件和controller函数中，可以直接调用this.getAche()来获取常量：EGGACHE\n接下来是第五点中的app/extend/helper.js，导出的方法会merge到app.Helper类的原型上去，而且比较有意思的是：app.context.helper强制指向了app.Helper的实例（Egg做了单例模式），所以我们同样可以将公共方法写入helper.js文件中，然后在中间件/controller函数中使用this.helper.xxx的形式调用，举个例子，helper.js的内容如下：</p>\n<pre class=\"prettyprint\"><code>exports.lowercaseFirst = str =&gt; str[0].toLowerCase() + str.substring(1);\n</code></pre><p>我们可以在中间件/controller函数中使用this.helper.lowercaseFirst方法，对字符串第一个字母进行小写处理。\napp/extend/helper.js还有一个和context.js不一样的地方在于，Egg框架默认将helper传入了模板引擎的locals参数中，所以在helper中定义的公共方法，我们在各种模板文件中同样可以直接调用，nunjucks中的调用形式为：</p>\n<pre class=\"prettyprint\"><code>{{ helper.lowercaseFirst() }}\n</code></pre><h4>五. app/middleware</h4>\n<p>middleware的编写需要和config下的配置文件结合起来，才能编写并且使得一个自定义中间件生效。以一个例子说明，在app/middleware下新建time_access.js，内容如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = (options, app)=&gt; {\n\treturn function * timeAccess(next) {\n    \tconsole.time(options.key);\n    \tyield next;\n    \tconsole.timeEnd(options.key);\n\t}\n};\n</code></pre><p>然后在config/config.default.js中编写如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = appInfo=&gt;{\n\treturn {\n\t\t&#x2F;&#x2F;“middleware”是固定的key不可变，值是一个数组，数组中每一个元素都表示开启的中间件名称（将上面的文件面进行小驼峰转换）。\n\t\tmiddleware: [‘timeAccess’],\n\t\t&#x2F;&#x2F;中间件所需的参数，key同样是上面的文件面进行小驼峰转换后的字符换，value就是中间件执行需要的参数。\n\t\ttimeAccess: {key: ‘Cost Time: ’}\n\t}\n}\n</code></pre><p>这样启动项目后，该中间件就生效了。config下文件编写可以参看V大节，我们这里主要来看下自定义中间件的写法，和参数的含义。\n可以看到time_access.js导出的是一个匿名函数，该函数的两个参数options和app，其中options对应的就是config.default.js中的timeAccess的值，这里是{key: ‘Cost Time: ’}，app则是本节第二小节中所描述的app实例，并且要使得该中间件生效，必须在config.default.js中的middleware值对应的数组里面有：’timeAccess’。\n看到这里你也许会有疑问，我的文件名字明明是time_access.js，为啥config配置中所有填写都是timeAccess呢，这里和controller一样，Egg框架为了统一变量的风格，所以会自动的对文件名进行小驼峰转换，那么time_access转换为小驼峰就是timeAccess。\n最后这个匿名函数执行后，返回的是一个标准的koa 1.x的中间件，写法用法和koa 1.x的中间件完全一致，这一块不清楚的可以看Koa 1.x的官方文档学习下。</p>\n<h4>六. app/public</h4>\n<p>这个文件夹下存放的是Web服务器所需的静态资源，这一块没什么好说的，随意放，访问使用/public/xxx就行了，xxx为你的静态资源在public目录下的相对路径。比如我们在app/public下新建了一个css文件叫index.css，则我们可以这样访问下载该文件：\n127.0.0.1:7001/public/index.css</p>\n<h4>七. app/service</h4>\n<p>好吧，终于到了service层了，这一块属于Egg设计的一个服务层，具体来说相当于带了业务逻辑的model，数据的获取和数据的组装都可以在service中完成，然后对于controller函数来说可能就只有两个动作了：</p>\n<ul>\n<li>Service调用</li>\n<li>Page页面渲染</li>\n</ul>\n<p>这样整体的逻辑看起来会更清楚一些。我们以一个例子来理解下service文件的编写方式，这个例子做的比较简单，全量获取百度主页的数据，文件名为BaiduService.js：</p>\n<pre class=\"prettyprint\"><code>module.exports = app=&gt;(class BaiduService extends app.Service {\n\tconstructor(ctx) {\n    \tsuper(ctx);\n    \tthis.config = this.app.config;\n\t}\n\t\n\t* getBaiduHomePage() {\n    \tlet data = yield new Promise((resolve, reject)=&gt; {\n        \trequire(&#x27;request&#x27;).get(&#x27;http:&#x2F;&#x2F;www.baidu.com&#x27;, function (err, res, data) {\n            if (err) return reject(err);\n            \treturn resolve(data);\n        \t})\n    \t});\n    \treturn data;\n\t}\n});\n</code></pre><p>可以看到，BaiduService.js导出的依旧是一个匿名函数，该匿名函数的参数app就是本大节中第二小节所描述的app。\n这个匿名函数由Egg框架执行后，返回的则是一个class，这个class继承自app.Service，其实在app.Service中，仅仅是对this.ctx和this.app赋值而已。\n返回的BaiduService类的构造函数没什么好说的，既然是继承了，必须先super()，然后就可以直接使用this.app来获取app对象，以及this.ctx来获取本次请求的context对象（这个context对象就是中间件和路由中的this对象）。\n那么我在这里定义了一个获取百度主页数据的generator成员函数，至此，整个service层样例已经写完了。接下来我们看看如何在controller中调用：</p>\n<pre class=\"prettyprint\"><code>module.exports = function *myHelloController() {\n\tlet data = yield this.service.baiduService.getBaiduHomePage();\n\tthis.body = data;\n};\n</code></pre><p>可以看到，Egg框架将BaiduService这个类new了一个实例，挂载到了this.service.baiduService属性上，因此我们可以直接按照上述的方式调用我们编写的数据获取方法，而且这里的BaiduService.js同样被自动转换成小驼峰的baiduService，所以在controller中的调用形式为：</p>\n<pre class=\"prettyprint\"><code>this.service.小驼峰文件名.成员函数名\n</code></pre><p>这里的类名是无关紧要的，调用依旧以service目录下创建类的文件名为绑定的key。\n<strong>这里要多说一句，经过源码阅读，理清了service加载的逻辑后，可以看到阿里的开发组成员在Service层的逻辑设计还是蛮用心的，this.service和this.controller不一样，它是在每一次请求中第一次使用到时才会new出来的；并且刚才在app/service目录下编写的类也一样，仅在每一次请求中第一次使用到该类时才会实例化；而且不管是this.service还是编写的类，一次会话请求的生命周期中都是单例运行的，这样节省了new类的开销，提升了Egg运行的效率。</strong></p>\n<h4>八. app/view</h4>\n<p>这一块没什么好说的了，模板引擎该怎么用就是怎么用的，但是就和本大节中第四小节描述的那样，app/extend/helper.js中的方法会自动merge到模板执行的locals中，因此在nunjucks中可以使用：</p>\n<pre class=\"prettyprint\"><code>{{ helper.xxx }}\n</code></pre><p>在ejs中可以使用：</p>\n<pre class=\"prettyprint\"><code>&lt;% helper.xxx %&gt;\n</code></pre><p>来调用编写到helper.js中的公共方法。</p>\n<h3>九. app/router.js</h3>\n<p>终于到了app目录下的最后一个文件了，顾名思义，router.js是编写路由的文件，编写形式如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = app =&gt; {\n\tapp.get(&#x27;&#x2F;home&#x27;, app.controller.home);\n\tapp.get(&#x27;&#x2F;myPage&#x27;, app.controller.myHello);\n\tapp.redirect(&#x27;&#x2F;&#x27;, &#x27;&#x2F;news&#x27;);\n\tapp.get(&#x27;&#x2F;news&#x27;, app.controller.news.list);\n\tapp.get(&#x27;&#x2F;news&#x2F;item&#x2F;:id&#x27;, app.controller.news.detail);\n\tapp.get(&#x27;&#x2F;news&#x2F;user&#x2F;:id&#x27;, app.controller.news.user);\n};\n</code></pre><p>这里依旧是返回的一个匿名函数，参数为app，其实整个Egg的加载逻辑大同小异，花点时间搞清楚controller/service/middleware/config中的一块，别的模块也很容易读懂。\n那么这里Egg显然做了一些处理，使得基于Koa 1.x的路由编写看起来和express的风格一致。\n由于在本大节第三小节中的controller编写和加载已经阐述过了，我们所编写的路由文件最后会被挂载到app.controller属性下，因此可以直接使用</p>\n<pre class=\"prettyprint\"><code>app.get(‘&#x2F;index’, app.controller.xxx)\n</code></pre><p>的形式来编写路由函数。</p>\n<h3>VII. 结语</h3>\n<p>写这东西，也算是挑战了下自己，本文总共5200多字全部纯手打；\nEgg框架总体来说设计思路还是非常值得借鉴的，在公司内部协作中，使用这样的强约束框架更能统一风格，提升项目阅读和维护性。\n还有就是我现在源码逻辑理的比较清楚集中在master进程fork出来的app子进程，但是对于agent子进程的作用不是很清楚，我大致看了下agent的实现，似乎目前给出的仅仅用到本地开发时由agent监听几个文件目录——只要这些文件目录下的文件发生变更，就由agent来重启app子进程。\n最后的是<strong>parent——master——app——agent</strong>四者间的通信的意义也没有了解的比较清楚，希望社区有阿里的大神看在我写的辛苦的份上来给我解答下~</p>\n</div>",
		"title": "深夜放毒——阿里开源的企业级Node框架Egg使用指南",
		"last_reply_at": "2022-05-07T13:30:57.124Z",
		"good": true,
		"top": false,
		"reply_count": 62,
		"visit_count": 73087,
		"create_at": "2016-10-21T19:20:30.342Z",
		"author": {
			"loginname": "hyj1991",
			"avatar_url": "https://avatars.githubusercontent.com/u/19908330?v=4&s=120"
		}
	}, {
		"id": "6275fbe879f90df2bea0dcfd",
		"author_id": "57346bbf32bf2c90579f529f",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>我使用好像检索不了，还会网页无法访问，什么问题呢？</p>\n</div>",
		"title": "请问一下，你们这个cnode社区顶部，header部分的内容搜索功能有用吗？",
		"last_reply_at": "2022-05-07T06:57:30.474Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 827,
		"create_at": "2022-05-07T04:56:08.472Z",
		"author": {
			"loginname": "dpc761218914",
			"avatar_url": "https://avatars.githubusercontent.com/u/16233212?v=4&s=120"
		}
	}, {
		"id": "607799714d20cbc44d68c484",
		"author_id": "5c81f15090c14711cc8cb87e",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h3>一、Serverless相关的概念</h3>\n<p>Serverless又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</p>\n<p><strong>Serverless相关视频教程</strong>：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n<p>Serverless是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时（运行时通俗的讲就是运行环境，比如nodejs环境，java环境，php环境）。Serverless真正做到了部署应用无需涉及基础设施的建设，自动构建、部署和启动服务。</p>\n<p><strong>通俗的讲：</strong>  Serverless 是构建和运行软件时不需要关心服务器的一种架构思想。老程序员都用过虚拟主机，刚开始学Serverless 你可以把它理解为虚拟主机的升级版本。\n<img src=\"//static.cnodejs.org/FrQYaZ4ed16DDtoKnmfMeyAR6cay\" alt=\"图片1.png\"></p>\n<p>虚拟主机已经是快被淘汰掉的上一代产物了。云计算涌现出很多改变传统IT架构和运维方式的新技术，比如虚拟机、容器、微服务，无论这些技术应用在哪些场景，降低成本、提升效率是云服务永恒的主题。Serverless的出现真正的解决了降低成本、提升效率的问题。它真正做到了弹性伸缩、高并发、按需收费、备份容灾、日志监控等。</p>\n<h3>二、传统模式和ServerLess模式下项目开发上线流程</h3>\n<p><strong>传统模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FkAKf0N_-FFBJeLkfHAIRIGRaHWB\" alt=\"图片2.png\"></p>\n<p><strong>Serverless模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FujjnTbCFWxsoRWvYvswpvsjvIYQ\" alt=\"图片3.png\"></p>\n<p>Serverless 正在改变未来软件开发的模式和流程\n<img src=\"//static.cnodejs.org/Fo0An9-HSBIKZzNJSYGnPVFmRD4A\" alt=\"图片4.png\"></p>\n<h3>三、Serverless 和ServerFul架构的区别</h3>\n<p><strong>1、传统的ServerFul 架构模式</strong>\nServerFul 架构就是 n 台 Server 通过 网络通信 的 方式 协作在一起，也可以说 ServerFul 架构是基于 Server和 网络通信（分布式计算） 的 软件实现架构 ， Server 可以是 虚拟机 物理机 ，以及基于硬件实现的云的云服务器。\n<img src=\"//static.cnodejs.org/FtT0j6_rKqbHrH016dakycYIanzS\" alt=\"图片5.png\"></p>\n<p><strong>2、Serverless  架构模式</strong></p>\n<p>Serverless 的核心特点就是实现自动弹性伸缩和按量付费。\n<img src=\"//static.cnodejs.org/FnQRSZtlryaZQzuzlosJ0FDO2WxH\" alt=\"图片6.png\"></p>\n<p><strong>相比ServerLes相比ServerFul 有下面一些特点：</strong></p>\n<p><strong>资源分配：</strong> 在 Serverless 架构中，你不用关心应用运行的资源（比如服务配置、磁盘大小）只提供一份代码就行。</p>\n<p><strong>计费方式：</strong> 在 Serverless 架构中，计费方式按实际使用量计费（比如函数调用次数、运行时长），不按传统的执行代码所需的资源计费（比如固定 CPU）。计费粒度也精确到了毫秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每个月40万GBs的资源使用额度和100万次调用次数的免费额度。中小企业的网站访问量不是特别大的话完全可以免费使用。</p>\n<p><strong>弹性伸缩</strong>： Serverless 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统架构对服务器（虚拟机）进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。</p>\n<p>Serverless相关视频教程：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n</div>",
		"title": "Serverless今年会火吗？",
		"last_reply_at": "2022-05-07T01:34:05.454Z",
		"good": false,
		"top": false,
		"reply_count": 50,
		"visit_count": 42837,
		"create_at": "2021-04-15T01:40:01.543Z",
		"author": {
			"loginname": "phonegap100",
			"avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
		}
	}, {
		"id": "62746f1a79f90da1efa0db5d",
		"author_id": "57346bbf32bf2c90579f529f",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmwfSEW0HTYHCDOylLL7tCcUD4CR\" alt=\"QQ图片20220506084201.png\">\n<img src=\"//static.cnodejs.org/FpopdT-uG-QoXI-XPgk9Dtr6QB1V\" alt=\"QQ图片20220506084154.png\"></p>\n</div>",
		"title": "请教node-club源代码导入运行报错，busboy？？？",
		"last_reply_at": "2022-05-06T08:53:49.497Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 657,
		"create_at": "2022-05-06T00:43:06.501Z",
		"author": {
			"loginname": "dpc761218914",
			"avatar_url": "https://avatars.githubusercontent.com/u/16233212?v=4&s=120"
		}
	}, {
		"id": "626d447a79f90d25a8a0d96c",
		"author_id": "60d301f5248d04bc274aea41",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>第一版食用jq写了个，全部展开收起不好实现就换vue写了</p>\n<p>copy值用的navigator,手机打开的时候复制不了</p>\n<pre class=\"prettyprint language-js\"><code>navigator.clipboard.writeText(value)\n</code></pre><p>帮忙看看用起来方便吗,有没有啥异常的</p>\n<p><img src=\"//static.cnodejs.org/FpcektUXKFs8PAiT9DJSnpVn3nLx\" alt=\"image.png\"></p>\n<p>jq：<a href=\"https://json-run.vercel.app/test2022\">https://json-run.vercel.app/test2022</a>\nvue：<a href=\"https://json-run.vercel.app/\">https://json-run.vercel.app/</a></p>\n</div>",
		"title": "照着别人的json格式化写了个简单的,帮忙看看食用吗",
		"last_reply_at": "2022-05-01T08:31:06.964Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 973,
		"create_at": "2022-04-30T14:15:22.679Z",
		"author": {
			"loginname": "divcssjs",
			"avatar_url": "https://avatars.githubusercontent.com/u/48471293?v=4&s=120"
		}
	}, {
		"id": "620b1504a08b3976a009cb29",
		"author_id": "54009f5ccd66f2eb37190485",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fn8Rd3JDKM4uigDE7FGbZnyYQ8kX\" alt=\"image.png\"></p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。</p>\n<p>2022年伊始，我们邀请到了Node.js 技术布道者狼叔来直播分享，为大家系统性地讲解Node.js 2022 应该关注的、有代表性的技术。</p>\n<p>直播讲师\n狼叔，淘系技术部前端技术专家，Node.js 技术布道者，Node全栈公众号运营者，曾就职于去哪儿、新浪、网秦，做过前端、后端、数据分析，是一名全栈技术的实践者。已出版《狼书(卷1) ：更了不起的Node.js》《狼书(卷2) ：Node.js Web应用开发》。即将出版《狼书(卷3) Node.js高级技术》。</p>\n<p>分享大纲</p>\n<ol>\n<li>\n<p>clipanion与ts</p>\n</li>\n<li>\n<p>find-my-way</p>\n</li>\n<li>\n<p>测试框架演进</p>\n</li>\n<li>\n<p>八大类web框架</p>\n</li>\n<li>\n<p>再看egg系列</p>\n</li>\n<li>\n<p>架构演进与前端3.0</p>\n</li>\n<li>\n<p>serverless</p>\n</li>\n<li>\n<p>ssr与next</p>\n</li>\n<li>\n<p>语雀的故事</p>\n</li>\n<li>\n<p>性能调优ezm的升级</p>\n</li>\n<li>\n<p>rush工程化</p>\n</li>\n</ol>\n<p>感兴趣的同学可以来一起聊聊</p>\n<p>回放地址  <a href=\"https://live.juejin.cn/4354/898051?utm_source=shouxin10&amp;utm_medium=shouxin&amp;utm_campaign=zhibo\">https://live.juejin.cn/4354/898051?utm_source=shouxin10&amp;utm_medium=shouxin&amp;utm_campaign=zhibo</a></p>\n</div>",
		"title": "【2月16日直播回放】学习指北：Node.js 2022 全解析",
		"last_reply_at": "2022-04-28T11:28:20.330Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 8581,
		"create_at": "2022-02-15T02:50:44.523Z",
		"author": {
			"loginname": "i5ting",
			"avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
		}
	}, {
		"id": "6229954ad9954ee2547f7e62",
		"author_id": "564c2f011ba2ef107f854d91",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>原发在掘金，掘金是越来越烂了。\n<a href=\"https://juejin.cn/post/7073156371008454663\">https://juejin.cn/post/7073156371008454663</a></p>\n<h2>楔子</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">postMessage</a> 常见于内嵌 <code>iframe</code> 或是 <code>Web Workers</code> 中，用于跨页面（线程） 的消息通信，在一些其他开发环境中也能看到类似的影子，如 Chrome 插件环境、Electron 环境、figma 插件等。</p>\n<p>最近的工作需要经常与 <code>iframe</code> 与 <code>Web Workers</code> 打交道，处理页面与内嵌页、主线程与 worker 通信，撸了个用于处理浏览器消息通信的处理的工具库 <a href=\"https://github.com/kinglisky/rpc-shooter\">rpc-shooter</a>，涵盖了浏览器主要的消息通信的接口支持：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">Window</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/postMessage\">Worker</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker\">SharedWorker</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker\">ServiceWorker</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel\">MessageChannel</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel\">BroadcastChannel</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MessagePort\">MessagePort</a></li>\n</ul>\n<p>在此分享一些开发过程中的经验与技巧。</p>\n<h2>原教旨主义</h2>\n<p>先来看一个 <code>iframe</code> 父子级页面通信的例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; parent.js\nconst childWindow = document.querySelector(&#x27;iframe&#x27;).contentWindow;\nwindow.addEventListener(&#x27;message&#x27;, function (event) {\n    const data = event.data;\n    if (data.method === &#x27;do_something&#x27;) {\n        &#x2F;&#x2F; ... handle iframe data\n        childWindow.postMessage({\n            method: &#x27;re:do_something&#x27;,\n            data: &#x27;some data&#x27;,\n        });\n    }\n});\n\n&#x2F;&#x2F; iframe.js\nwindow.top.postMessage(\n    {\n        method: &#x27;do_something&#x27;,\n        data: &#x27;ifame data&#x27;,\n    },\n    &#x27;*&#x27;\n);\nwindow.addEventListener(&#x27;message&#x27;, function (event) {\n    const data = event.data;\n    if (data.method === &#x27;re:do_something&#x27;) {\n        &#x2F;&#x2F; ... handle parent data\n    }\n});\n</code></pre><p>使用原教旨主义的写法可以很容写出上述代码，处理简单消息通信不会有什么问题，但针对复杂场景下跨页面（线程）通信则需要有个简单有效机制来维护消息通信。</p>\n<p>聪明的你一定想到了基于<strong>统一消息格式</strong>配合对应的消息<strong>处理策略</strong>来维护消息事件的方法调用，很简单的机制，却很好用：</p>\n<pre class=\"prettyprint language-ts\"><code>const childWindow = document.querySelector(&#x27;iframe&#x27;).contentWindow;\nconst handlers = {\n    add: (a: number, b: number) =&gt; a + b,\n    subtract: (a: number, b: number) =&gt; a - b,\n};\nwindow.addEventListener(&#x27;message&#x27;, function (event) {\n    const { method, args } = event.data;\n    const result = handlers[method](...args);\n    childWindow.postMessage({\n        method: &#96;re:${method}&#96;,\n        args: [result],\n    });\n});\n</code></pre><p>使用上述的处理方式，消息通信的处理维护一份策略处理函数即可，接下来的工作也是建立在此基础上的，加一点“细节”即可。</p>\n<h2>事件封装</h2>\n<p>消息通信本身是事件的一种，所以不妨往事件封装的方向靠，这时候就有很多可以借鉴的接口设计了，这里可以借鉴 <a href=\"https://socket.io/\">socket.io</a> 的接口设计。相对与本地事件调用，消息通信则本质是监听远程服务所发出的事件，与 <a href=\"http://socket.io\">socket.io</a> 类似：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; client\nsocket.emit(&#x27;join-in&#x27;, input.value);\n&#x2F;&#x2F; server\nsocket.on(&#x27;join-in&#x27;,(user) =&gt; {...});\n</code></pre><h3>面向接口</h3>\n<p>对于一个工具函数（库）的封装设计，最好是从<strong>接口开始</strong>，接口设计可以直接决定最终工具使用形式。这也是 Typescript 带来的开发模式转变，面向接口的设计，可以帮助我们更好组装模块以达到解耦的目的。</p>\n<p>封装的接口格式定义：</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCHandler {\n    (...args: any[]): any;\n}\n\ninterface RPCEvent {\n    emit(event: string, ...args: any[]): void;\n    on(event: string, fn: RPCHandler): void;\n    off(event: string, fn?: RPCHandler): void;\n}\n</code></pre><p>基于上述定义的接口，以 <code>iframe</code> 的父子通信为例做工具库封装：</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCHandler {\n    (...args: any[]): any;\n}\n\ninterface RPCEvent {\n    emit(event: string, ...args: any[]): void;\n    on(event: string, fn: RPCHandler): void;\n    off(event: string, fn?: RPCHandler): void;\n}\n\ninterface RPCMessageDataFormat {\n    event: string;\n    args: any[];\n}\n\ninterface RPCMessageEventOptions {\n    currentEndpoint: Window;\n    targetEndpoint: Window;\n    targetOrigin: string;\n}\n\nclass RPCMessageEvent implements RPCEvent {\n    private _currentEndpoint: RPCMessageEventOptions[&#x27;currentEndpoint&#x27;];\n    private _targetEndpoint: RPCMessageEventOptions[&#x27;targetEndpoint&#x27;];\n    private _targetOrigin: RPCMessageEventOptions[&#x27;targetOrigin&#x27;];\n    private _events: Record&lt;string, Array&lt;RPCHandler&gt;&gt;;\n\n    constructor(options: RPCMessageEventOptions) {\n        this._events = {};\n        this._currentEndpoint = options.currentEndpoint;\n        this._targetEndpoint = options.targetEndpoint;\n        this._targetOrigin = options.targetOrigin;\n        &#x2F;&#x2F; 监听远程消息事件\n        const receiveMessage = (event: MessageEvent) =&gt; {\n            const { data } = event;\n            const eventHandlers = this._events[data.event] || [];\n            if (eventHandlers.length) {\n                eventHandlers.forEach((handler) =&gt; {\n                    handler(...(data.args || []));\n                });\n                return;\n            }\n        };\n        this._currentEndpoint.addEventListener(\n            &#x27;message&#x27;,\n            receiveMessage as EventListenerOrEventListenerObject,\n            false\n        );\n    }\n\n    emit(event: string, ...args: any[]): void {\n        const data: RPCMessageDataFormat = {\n            event,\n            args,\n        };\n        &#x2F;&#x2F; postMessage\n        this._targetEndpoint.postMessage(data, this._targetOrigin);\n    }\n\n    on(event: string, fn: RPCHandler): void {\n        if (!this._events[event]) {\n            this._events[event] = [];\n        }\n        this._events[event].push(fn);\n    }\n\n    off(event: string, fn?: RPCHandler): void {\n        if (!this._events[event]) return;\n        if (!fn) {\n            this._events[event] = [];\n            return;\n        }\n        const handlers = this._events[event] || [];\n        this._events[event] = handlers.filter((handler) =&gt; handler !== fn);\n    }\n}\n</code></pre><p>经典的事件实现，这里不做赘述，使用方式如下：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 父级页面\nconst childWindow = document.querySelector(&#x27;iframe&#x27;).contentWindow;\nconst parentEvent: RPCEvent = new RPCMessageEvent({\n    targetEndpoint: window,\n    currentEndpoint: childWindow,\n    targetOrigin: &#x27;*&#x27;,\n});\nparentEvent.on(&#x27;add&#x27;, (a, b) =&gt; a + b);\nparentEvent.emit(&#x27;test&#x27;);\n\n&#x2F;&#x2F; 子级页面\nconst childEvent: RPCEvent = new RPCMessageEvent({\n    targetEndpoint: window,\n    currentEndpoint: window.top,\n    targetOrigin: &#x27;&#x27;,\n});\nchildEvent.emit(&#x27;add&#x27;, 1, 2);\nchildEvent.on(&#x27;test&#x27;, () =&gt; {});\nchildEvent.on(&#x27;max&#x27;, (a, b) =&gt; Math.max(a, b));\nchildEvent.off(&#x27;max&#x27;);\n</code></pre><p>思考一个问题，上述实现了父子级 window 对象的消息通信封装，能否将其一般化支持到所有浏览器消息事件？</p>\n<p>答案是肯定的，看一眼事件的 Window 封装初始化选项：</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCMessageEventOptions {\n    currentEndpoint: Window;\n    targetEndpoint: Window;\n    targetOrigin: string;\n}\n</code></pre><p>这里的事件接收与发送对象都是 <code>Window</code>，但实际上我们只是依赖了：</p>\n<ul>\n<li>currentEndpoint 上的 <code>message</code> 事件</li>\n<li>targetEndpoint 上的 <code>postMessage</code> 方法与其配置</li>\n</ul>\n<p><strong>换言之，只要浏览器中的其他对象支持 <code>message</code> 事件与 <code>postMessage</code> 方法即可实现同样的封装，即满足接口即可</strong>。</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCMessageEventOptions {\n    currentEndpoint: {\n        addEventListener&lt;K extends keyof MessagePortEventMap&gt;(\n            type: K,\n            listener: (\n                this: RPCMessageEventOptions[&#x27;currentEndpoint&#x27;],\n                ev: MessagePortEventMap[K]\n            ) =&gt; any,\n            options?: boolean | AddEventListenerOptions\n        ): void;\n    };\n    targetEndpoint: {\n        postMessage(message: any, ...args: any[]): void;\n    };\n}\n</code></pre><h3>浏览器中通信接口</h3>\n<p>以下为目前浏览器主要支持消息通信的对象，其都实现了类似消息事件接口：</p>\n<pre class=\"prettyprint language-ts\"><code>interface MessagePort extends EventTarget {\n    postMessage(message: any, transfer: Transferable[]): void;\n    postMessage(message: any, options?: StructuredSerializeOptions): void;\n    addEventListener&lt;K extends keyof MessagePortEventMap&gt;(\n        type: K,\n        listener: (this: MessagePort, ev: MessagePortEventMap[K]) =&gt; any,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener&lt;K extends keyof MessagePortEventMap&gt;(\n        type: K,\n        listener: (this: MessagePort, ev: MessagePortEventMap[K]) =&gt; any,\n        options?: boolean | EventListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | EventListenerOptions\n    ): void;\n}\n</code></pre><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a63c757e182b4a77b9386fa735310ee9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3be12c0bdf9d401a948b4888ce6c907b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43422cea86534ce59d5e264e10af5a16~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbfd66a34ab4d1f99f244f596725e5f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>有兴趣的同学可以翻一翻 <code>lib.dom.d.ts</code> 接口定义，有时会比翻文档来的清楚：</p>\n<ul>\n<li><a href=\"https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts#L17278\">Window</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts#L17389\">Worker</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts#L13951\">ServiceWorker</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts#L2457\">BroadcastChannel</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts#L10126\">MessagePort</a></li>\n</ul>\n<p>综上我们可以整一个终极缝合怪来适配所有接口：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 消息发送对象的接口定义\ninterface AbstractMessageSendEndpoint {\n    &#x2F;&#x2F; BroadcastChannel\n    postMessage(message: any): void;\n    &#x2F;&#x2F; Wroker &amp;&amp; ServiceWorker &amp;&amp; MessagePort\n    postMessage(message: any, transfer: Transferable[]): void;\n    postMessage(message: any, options?: StructuredSerializeOptions): void;\n    &#x2F;&#x2F; window\n    postMessage(message: any, options?: WindowPostMessageOptions): void;\n    postMessage(message: any, targetOrigin: string, transfer?: Transferable[]): void;\n}\n\n&#x2F;&#x2F; 消息接收对象的接口定义\ninterface AbstractMessageReceiveEndpoint extends EventTarget, AbstractMessageSendEndpoint {\n    onmessage?: ((this: AbstractMessageReceiveEndpoint, ev: MessageEvent) =&gt; any) | null;\n    onmessageerror?: ((this: AbstractMessageReceiveEndpoint, ev: MessageEvent) =&gt; any) | null;\n    close?: () =&gt; void;\n    start?: () =&gt; void;\n\n    addEventListener&lt;K extends keyof MessagePortEventMap&gt;(\n        type: K,\n        listener: (this: AbstractMessageReceiveEndpoint, ev: MessagePortEventMap[K]) =&gt; any,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    removeEventListener&lt;K extends keyof MessagePortEventMap&gt;(\n        type: K,\n        listener: (this: AbstractMessageReceiveEndpoint, ev: MessagePortEventMap[K]) =&gt; any,\n        options?: boolean | EventListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | EventListenerOptions\n    ): void;\n}\n</code></pre><p>需要注意 postMessage 接口定义，实际使用 WindowPostMessageOptions 接口即可涵盖目前所有的消息通信，其包含了 <code>targetOrigin</code> 与 <code>transfer</code> 配置。</p>\n<pre class=\"prettyprint language-ts\"><code>interface StructuredSerializeOptions {\n    transfer?: Transferable[];\n}\n\ninterface WindowPostMessageOptions extends StructuredSerializeOptions {\n    targetOrigin?: string;\n}\n\ninterface AbstractMessageSendEndpoint {\n    postMessage(message: any, options?: WindowPostMessageOptions): void;\n}\n</code></pre><p>最终的事件初始化选项接口如下，新增了一个 config 配置项用于给 postMessage 传递配置参数：</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCMessageEventOptions {\n    currentEndpoint: AbstractMessageReceiveEndpoint;\n    targetEndpoint: AbstractMessageSendEndpoint;\n    config?:\n        | ((data: any, context: AbstractMessageSendEndpoint) =&gt; WindowPostMessageOptions)\n        | WindowPostMessageOptions;\n}\n</code></pre><p>具体封装实现可以戳这里看 <a href=\"https://github.com/kinglisky/rpc-shooter/blob/master/src/index.ts#L115\">RPCMessageEvent 的实现</a>，<strong>面向接口的设计可以很好将同一类问题归一抽象</strong>，即使往后浏览器新增了新的通信机制，只要其还满足这套接口配置，那我们的封装就还是有效的。</p>\n<h2>远程过程调用（RPC）</h2>\n<p>经过上面的封装我们得到一个基于事件驱动的消息通信工具，但这还不够，因为其使用还较为原子化（原始），处理消息回复显得繁琐，举个例子：</p>\n<pre class=\"prettyprint language-ts\"><code>import { RPCMessageEvent } from &#x27;rpc-shooter&#x27;;\n&#x2F;&#x2F; main\nconst mainEvent = new RPCMessageEvent({\n    currentEndpoint: window,\n    targetEndpoint: iframe.contentWindow,\n    config: {\n        targetOrigin: &#x27;*&#x27;,\n    },\n});\nmainEvent.on(&#x27;reply:max&#x27;, (data) =&gt; {\n    console.log(&#x27;invoke max result:&#x27;, data);\n});\nmainEvent.emit(&#x27;max&#x27;, 1, 2);\n\n&#x2F;&#x2F; child\nconst childEvent = new RPCMessageEvent({\n    currentEndpoint: window,\n    targetEndpoint: window.top,\n});\nchildEvent.on(&#x27;max&#x27;, (a, b) =&gt; {\n    const result = Math.max(a, b);\n    childEvent.emit(&#x27;reply:max&#x27;, result);\n});\n</code></pre><p>当 <code>main</code> 中调用 <code>child</code> 的 <code>max</code> 方法时还需要监听一个 <code>child</code> 中的回复（<code>reply:max</code>）事件，<code>child</code> 接受消息调用方法成功后也需要 emit 一个 <code>reply:max</code> 事件。这一来一回并不优雅，眼不看为净，还需要再做一层封装包装事件的触发与响应。</p>\n<h3>promisify</h3>\n<p>异步事件自然使用 Promise 比较合理，封装也比较简单：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; child\nfunction registerMethod(method: string, handler: RPCHandler) {\n    const synEventName = &#96;syn:${method}&#96;;\n    const ackEventName = &#96;ack:${method}&#96;;\n    const synEventHandler = (data) =&gt; {\n        Promise.resolve(handler(data.params)).then((result) =&gt; {\n            this._event.emit(ackEventName, result);\n        });\n    };\n    this._event.on(synEventName, synEventHandler);\n}\nregisterMethod(&#x27;max&#x27;, ([a, b]) =&gt; Math.max(a, b));\n\n&#x2F;&#x2F; main\nfunction invoke(method: string, params: any): Promise&lt;any&gt; {\n    return new Promise((resolve) =&gt; {\n        const synEventName = &#96;syc:${method}&#96;;\n        const ackEventName = &#96;ack:${method}&#96;;\n        this._event.emit(synEventName, params);\n        this._event.on(ackEventName, (res) =&gt; {\n            resolve(res);\n        });\n    });\n}\ninvoke(&#x27;max&#x27;, [1, 2]).then((res) =&gt; {\n    console.log(res);\n});\n</code></pre><p>调用方 emit 一个带有 <code>syc:</code> 前缀的事件，被调用方注册并监听同名事件，消息调用成功后回复一个带 <code>ack:</code> 前缀事件，调用方监听 <code>ack:</code> 事件标识一次消息相应成功，Promise.resolve。</p>\n<p>promisify 简单，但实际使用消息通信会遇到各种各样的问题：</p>\n<ul>\n<li>远程方法调用错误</li>\n<li>调用方法不存在</li>\n<li>连接超时</li>\n<li>数据格式错误（如 worker 中错误传递了无法序列化 dom 对象）</li>\n<li>…</li>\n</ul>\n<p>针对通信过程各种情况我们需要将其描述出来。</p>\n<p>实际上网页消息通信过程与 <a href=\"https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8\">RPC</a> 调用十分类似，可类比于调用远程服务的方法。而刚好有个 <a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html\">JSON-RPC</a> 协议规范可以十分简单清晰描述此过程，不妨借来用一用。</p>\n<h3>JSON-RPC</h3>\n<blockquote>\n<p>JSON-RPC 是一个无状态且轻量级的远程过程调用(RPC)协议。 本规范主要定义了一些数据结构及其相关的处理规则。它允许运行在基于 socket,http 等诸多不同消息传输环境的同一进程中。其使用<a href=\"http://www.json.org/\">JSON</a>（<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>）作为数据格式。</p>\n</blockquote>\n<p>相对动则几百页 http 协议规范，JSON-RPC 的规范很简单，只有一页，有兴趣的同学可以研究下 <a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html\">JSON-RPC 2.0 规范</a>。</p>\n<p>这里主要看一下 JSON-RPC 定义请求与响应的数据格式：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 错误对象\ninterface RPCError {\n    code: number;\n    message: string;\n    data: any;\n}\n\n&#x2F;&#x2F; RPC 请求对象\ninterface RPCSYNEvent {\n    jsonrpc: &#x27;2.0&#x27;;\n    method: string;\n    params: any;\n    id?: string;\n}\n\n&#x2F;&#x2F; RPC 响应\ninterface RPCSACKEvent {\n    jsonrpc: &#x27;2.0&#x27;;\n    result?: any;\n    error?: RPCError;\n    id?: string;\n}\n</code></pre><p>带索引数组参数的 rpc 调用:</p>\n<pre class=\"prettyprint language-json\"><code>--&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: [42, 23], &quot;id&quot;: 1}\n&lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19, &quot;id&quot;: 1}\n</code></pre><p>通知:</p>\n<pre class=\"prettyprint language-json\"><code>--&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;update&quot;, &quot;params&quot;: [1,2,3,4,5]}\n--&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;foobar&quot;}\n</code></pre><p>不包含调用方法的 rpc 调用:</p>\n<pre class=\"prettyprint language-json\"><code>--&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;foobar&quot;, &quot;id&quot;: &quot;1&quot;}\n&lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: {&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;}, &quot;id&quot;: &quot;1&quot;}\n</code></pre><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31906a002cab41fcb9d74a99ea424673~tplv-k3u1fbpfcp-watermark.image?\" alt=\"f29d024d03b32c0a94b8460f8bbe25f.jpg\"></p>\n<p>规范中最重要的几条规则如下：</p>\n<p><strong>id</strong></p>\n<blockquote>\n<p>已建立客户端的唯一标识 id，值必须包含一个字符串、数值或 NULL 空值。如果不包含该成员则被认定为是一个通知。该值一般不为 NULL<a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html#id1\">[1]</a>，若为数值则不应该包含小数<a href=\"http://wiki.geekdream.com/Specification/json-rpc_2.0.html#id2\">[2]</a>。</p>\n</blockquote>\n<p>每次调用需要有个唯一 id 标识此次调用，因为我们可能会多次调用同一个远程服务，需要需要有个 id 来标识每次调用。如果没有 id 则表示调用方并不关心调用结果（表示此次调用是一次通知）。</p>\n<p><strong>error</strong> 和 <strong>result</strong></p>\n<blockquote>\n<p>响应对象必须包含 result 或 error 成员，但两个成员必须不能同时包含。</p>\n</blockquote>\n<p>调用失败返回 error，result 为空，调用成功返回 result，error 为空，有 error 对象时则表示调用失败。</p>\n<p>JOSN-RPC 协议简单明了描述数据请求与响应，我们只需要按照其要求封装 Promise 调用，成功时 resolve 失败时 reject 即可。</p>\n<h3>封装实现</h3>\n<p>还是老规矩，先看一样接口定义：</p>\n<pre class=\"prettyprint language-ts\"><code>interface RPCHandler {\n    (...args: any[]): any;\n}\n\ninterface RPCEvent {\n    emit(event: string, ...args: any[]): void;\n    on(event: string, fn: RPCHandler): void;\n    off(event: string, fn?: RPCHandler): void;\n}\n\ninterface RPCInitOptions {\n    event: RPCEvent;\n    methods?: Record&lt;string, RPCHandler&gt;;\n    timeout?: number;\n}\n\ninterface RPCInvokeOptions {\n    isNotify: boolean;\n    timeout?: number;\n}\n\ndeclare class RPC {\n    private _event;\n    private _methods;\n    static uuid(): string;\n    constructor(options: RPCInitOptions);\n    registerMethod(method: string, handler: RPCHandler): void;\n    removeMethod(method: string): void;\n    invoke(method: string, params: any, options?: RPCInvokeOptions): Promise&lt;any&gt;;\n}\n</code></pre><p>具体封装可看 <a href=\"https://github.com/kinglisky/rpc-shooter/blob/master/src/index.ts#L266\">RPC 实现</a>，最终 RPC 工具方式如下：</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; main.ts\nimport { RPCMessageEvent, RPC } from &#x27;rpc-shooter&#x27;;\n\n(async function () {\n    const iframe = document.querySelector(&#x27;iframe&#x27;)!;\n    const rpc = new RPC({\n        event: new RPCMessageEvent({\n            currentEndpoint: window,\n            targetEndpoint: iframe.contentWindow!,\n            config: { targetOrigin: &#x27;*&#x27; },\n        }),\n        &#x2F;&#x2F; 初始化时注册处理函数\n        methods: {\n            &#x27;Main.max&#x27;: (a: number, b: number) =&gt; Math.max(a, b),\n        },\n    });\n    &#x2F;&#x2F; 动态注册处理函数\n    rpc.registerMethod(&#x27;Main.min&#x27;, (a: number, b: number) =&gt; {\n        return Promise.resolve(Math.min(a, b));\n    });\n\n    &#x2F;&#x2F; 调用 iframe 服务中的注册方法\n    const randomValue = await rpc.invoke(&#x27;Child.random&#x27;, null, { isNotify: false, timeout: 2000 });\n    console.log(&#96;Main invoke Child.random result: ${randomValue}&#96;);\n})();\n</code></pre><pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; child.ts\nimport { RPCMessageEvent, RPC } from &#x27;rpc-shooter&#x27;;\n(async function () {\n    const rpc = new RPC({\n        event: new RPCMessageEvent({\n            currentEndpoint: window,\n            targetEndpoint: window.top,\n        }),\n    });\n\n    rpc.registerMethod(&#x27;Child.random&#x27;, () =&gt; Math.random());\n\n    const max = await rpc.invoke(&#x27;Main.max&#x27;, [1, 2]);\n    const min = await rpc.invoke(&#x27;Main.min&#x27;, [1, 2]);\n    console.log({ max, min });\n})();\n</code></pre><p>有一点需要注意以下，在 RPC 初始化实际我们只依赖 <code>RPCEvent</code> 接口，浏览器的通信是由 <code>RPCMessageEvent</code> 模块实现的，我们也可将其换成其他的业务实现，如使用 <a href=\"https://socket.io/\">socket.io</a> 来替代 <code>RPCMessageEvent</code> 以达到和服务端通信的目的，又一个面向接口开发的好处。</p>\n<p>至此我们完成从基本消息通信到页面 RPC 服务调用的封装，对实现细节有兴趣的同学可以戳：<a href=\"https://github.com/kinglisky/rpc-shooter\">rpc-shooter</a> 欢迎指教。</p>\n<p>附注：Google 专业解决 worker 调用的工具库 <a href=\"https://github.com/GoogleChromeLabs/comlink\">comlink</a>，有生产需要同学可以试试。</p>\n<h2>其他</h2>\n<p><a href=\"https://github.com/kinglisky/rpc-shooter\">rpc-shooter</a> 的开发过程学到不少东西，也是目前自己写得比较上心的一个小工具，有胆大小伙伴不妨来试试。</p>\n<p>个人感受是：</p>\n<ul>\n<li>TS 真香</li>\n<li>接口优先、接口优先、还是接口优先</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ba70852046c473d90d235f031e326ec~tplv-k3u1fbpfcp-watermark.image?\" alt=\"微信图片_20220310023005.jpg\">\nover~</p>\n</div>",
		"title": "JSON-RPC & postMessage 谈谈浏览器消息通信的封装技巧",
		"last_reply_at": "2022-04-25T05:38:15.468Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 4358,
		"create_at": "2022-03-10T06:06:02.539Z",
		"author": {
			"loginname": "kinglisky",
			"avatar_url": "https://avatars.githubusercontent.com/u/15852576?v=4&s=120"
		}
	}, {
		"id": "625e1cfa79f90db604a0cec0",
		"author_id": "59f688a1323d3667540dad98",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>在线地址：<a href=\"https://editor.runjs.cool/\">https://editor.runjs.cool/</a>\n代码仓库：<a href=\"https://github.com/maqi1520/mdx-editor\">https://github.com/maqi1520/mdx-editor</a></p>\n</div>",
		"title": "【开源自荐】基于MDX 的微信排版编辑器，可自定义组件、样式、可导出 markdown 和 PDF",
		"last_reply_at": "2022-04-24T11:07:09.110Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 1792,
		"create_at": "2022-04-19T02:22:50.048Z",
		"author": {
			"loginname": "BardMa",
			"avatar_url": "https://avatars.githubusercontent.com/u/9312044?v=4&s=120"
		}
	}, {
		"id": "6258cd7b79f90d7965a0cbf5",
		"author_id": "5d44f5954f472f7fee15236f",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>疫情当前，每天都被提交健康码和行程码支配着。于是做了这个小功能，自动识别健康码和行程码：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1G94y1o7HQ/\">https://www.bilibili.com/video/BV1G94y1o7HQ/</a></p>\n</div>",
		"title": "低代码搞了一个自动识别健康码和行程码，大佬们看看有没有用",
		"last_reply_at": "2022-04-23T12:00:37.004Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 2363,
		"create_at": "2022-04-15T01:42:19.767Z",
		"author": {
			"loginname": "dafanzhi",
			"avatar_url": "https://avatars.githubusercontent.com/u/53632540?v=4&s=120"
		}
	}, {
		"id": "625f65a779f90d0b4ca0cfc2",
		"author_id": "5dc8d79d865a9844a3021214",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/nodejs/node/releases/tag/v18.0.0\">https://github.com/nodejs/node/releases/tag/v18.0.0</a></p>\n</div>",
		"title": "node18来了代号氢气😂",
		"last_reply_at": "2022-04-23T11:52:05.483Z",
		"good": false,
		"top": false,
		"reply_count": 3,
		"visit_count": 2211,
		"create_at": "2022-04-20T01:45:11.060Z",
		"author": {
			"loginname": "chenkai0520",
			"avatar_url": "https://avatars.githubusercontent.com/u/30174970?v=4&s=120"
		}
	}, {
		"id": "6262287b79f90d4481a0d26b",
		"author_id": "60460ff34655eaadc021a4db",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>突然发现我不知道有哪些网站或服务是由 Node 开发的，心中不禁生出一阵失落。所以恳请 CNode 添加 /sites 页面，类似于 <a href=\"https://ruby-china.org/sites\">https://ruby-china.org/sites</a> 。\n这也可以让我们更加了解 Node 这门技术。如果有大网站的背书，就更好了。</p>\n</div>",
		"title": "恳请 CNode 添加 /sites 页面",
		"last_reply_at": "2022-04-23T02:12:23.145Z",
		"good": false,
		"top": false,
		"reply_count": 1,
		"visit_count": 1545,
		"create_at": "2022-04-22T04:00:59.672Z",
		"author": {
			"loginname": "enzeberg",
			"avatar_url": "https://avatars.githubusercontent.com/u/18072932?v=4&s=120"
		}
	}, {
		"id": "62429ddfd9954eb95a7f90b3",
		"author_id": "611393dca5d29dbb362d5eef",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FluDB3Y2ygT48UPL5vjGZ9KvgHGv\" alt=\"WechatIMG119.jpeg\"></p>\n</div>",
		"title": "npm install sharp 报错",
		"last_reply_at": "2022-04-22T12:09:56.780Z",
		"good": false,
		"top": false,
		"reply_count": 5,
		"visit_count": 2870,
		"create_at": "2022-03-29T05:49:19.747Z",
		"author": {
			"loginname": "huge689",
			"avatar_url": "https://avatars.githubusercontent.com/u/44516016?v=4&s=120"
		}
	}, {
		"id": "626111c779f90dd6f6a0d149",
		"author_id": "4efc278625fa69ac690005b1",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>npm run dev运行正常，但打包出错。\n在context.tsx中定义了context\nconst Context = createContext();\n在_app.tsx中使用Context，并赋值一堆变量\n&lt;Context.Provider  value={{isDark, setIsDark, walletAddress, setWalletAddress}}&gt;\n&lt;Component {…pageProps} /&gt;\n&lt;/Context.Provider&gt;\n在build时，提示createContext缺少变量\nType error: Expected 1 arguments</p>\n<p>改为\nconst Context = createContext(undefined);\n提示Type error: Property ‘inviteConfirm’ does not exist on type ‘undefined’.</p>\n<p>请教各位如何解决？</p>\n</div>",
		"title": "next.js打包出错",
		"last_reply_at": "2022-04-21T08:11:51.345Z",
		"good": false,
		"top": false,
		"reply_count": 0,
		"visit_count": 1580,
		"create_at": "2022-04-21T08:11:51.345Z",
		"author": {
			"loginname": "hunk",
			"avatar_url": "//gravatar.com/avatar/7d3c19500e2ed481fea3ab09f91e3856?s=48"
		}
	}, {
		"id": "623fd33bd9954ec9e47f8e96",
		"author_id": "60460ff34655eaadc021a4db",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>我用 Express 做了个静态服务器，主要响应图片请求，但我感觉图片的加载速度实在是太慢了！\n这是静态服务器：<a href=\"https://static.tonzhon.com/playlist_covers/61ea88e2fcd9f68bc9470edde2f803dd.png\">https://static.tonzhon.com/playlist_covers/61ea88e2fcd9f68bc9470edde2f803dd.png</a></p>\n<p>这个网站（<a href=\"https://tonzhon.com\">https://tonzhon.com</a>）上的图片全部来自于这个静态服务器，大家可以翻页看看，图片加载真地很慢！</p>\n<p>请问大家能帮我解决这个问题吗？\n感谢！</p>\n</div>",
		"title": "请问大家用什么框架搭建静态服务器比较好啊？",
		"last_reply_at": "2022-04-20T00:36:55.993Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 3767,
		"create_at": "2022-03-27T03:00:11.054Z",
		"author": {
			"loginname": "enzeberg",
			"avatar_url": "https://avatars.githubusercontent.com/u/18072932?v=4&s=120"
		}
	}, {
		"id": "60534c9adac542387be2833c",
		"author_id": "60460ff34655eaadc021a4db",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><h1><a href=\"https://tonzhon.com\">https://tonzhon.com</a></h1>\n<p>Repo: <a href=\"https://github.com/enzeberg/tonzhon-music\">https://github.com/enzeberg/tonzhon-music</a></p>\n<h2>背景</h2>\n<p>当今音乐版权竞争激烈，我们经常需要去往不同的音乐平台来满足我们的听歌需求，相当麻烦。铜钟则试图将分散的音乐资源聚集起来，来尽力满足用户“在一处聆听所有音乐”的诉求。而QQ音乐、网易云音乐和酷我音乐几乎囊括了市场上所有的主流音乐，因此铜钟选择将这三者的音乐资源聚到一处，呈现给用户，为用户带来了极大的便捷和独特的听歌体验。</p>\n<h2>功能</h2>\n<ul>\n<li>搜索（如: <a href=\"https://tonzhon.com/search?keyword=%E5%9B%9E%E6%A2%A6%E6%B8%B8%E4%BB%99\">https://tonzhon.com/search?keyword=%E5%9B%9E%E6%A2%A6%E6%B8%B8%E4%BB%99</a>）</li>\n<li>播放</li>\n<li>下载歌曲</li>\n<li>收藏歌曲，创建歌单</li>\n<li>发现歌单</li>\n<li>Top 100</li>\n<li>热歌榜</li>\n<li>导入网易云音乐的<strong>完整</strong>歌单 （<a href=\"http://lite.tonzhon.com\">http://lite.tonzhon.com</a>）</li>\n</ul>\n<h2>技术</h2>\n<ul>\n<li>Express.js</li>\n<li>React</li>\n</ul>\n<p>欢迎大家交流看法！</p>\n</div>",
		"title": "分享一下我用 Node.js 写的音乐网站",
		"last_reply_at": "2022-04-20T00:33:36.993Z",
		"good": false,
		"top": false,
		"reply_count": 20,
		"visit_count": 13330,
		"create_at": "2021-03-18T12:50:34.145Z",
		"author": {
			"loginname": "enzeberg",
			"avatar_url": "https://avatars.githubusercontent.com/u/18072932?v=4&s=120"
		}
	}, {
		"id": "56ded164255ed94c6e4c26c6",
		"author_id": "565553143325bb2c4ebd803a",
		"tab": "ask",
		"content": "<div class=\"markdown-text\"><p>最近在看generator的东西，发现大部分的介绍都是利用它来减少callback hell。但是我在 <a href=\"http://www.v2ex.com/t/135335\">这个讨论</a>中发现原来generator并不是设计用来处理异步编程/回掉的，它本质上应该是协程。我现在有这样的疑问：\n<strong>1，generator的出现是为了解决什么问题，它的本质就是协程吗？</strong>\n<strong>2，在什么样的场景下应该使用generator？</strong>\n（PS：我目前在项目中使用了大量的Promise来解决异步调用，写法看起来也很像是同步，例如\nPromise.resolve()\n.then(doSomething1)\n.then(doSomething2)\n.then(doSomething3)\n.catch(catchError)\n感觉这样代码可读性也好，不知道引入generator来改写会不会有什么好处）</p>\n</div>",
		"title": "es6引入generator的目的是什么，如何正确地使用generator？",
		"last_reply_at": "2022-04-18T03:41:08.170Z",
		"good": false,
		"top": false,
		"reply_count": 7,
		"visit_count": 7824,
		"create_at": "2016-03-08T13:19:32.451Z",
		"author": {
			"loginname": "youth7",
			"avatar_url": "https://avatars.githubusercontent.com/u/8315732?v=4&s=120"
		}
	}, {
		"id": "6095f0834d20cb84966910a9",
		"author_id": "5e81836f58ab6717beb7d52e",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FjgciAWezpKNPfn4QxCoUo0EYiHT\" alt=\"截屏2021-05-08 上午9.42.30.png\"></p>\n<h2>地址</h2>\n<ul>\n<li>\n<p><a href=\"https://github.com/cool-team-official/cool-admin-midway\">⚡️ midwayjs3.0 + typeorm + mysql + jwt </a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/cool-team-official/cool-admin-vue\">⚡️ vue2.x + element-ui</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/cool-team-official/cool-admin-vue/tree/vue3-ts-webpack\">⚡️ vue3.x + element-plus + ts + webpack</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/cool-team-official/cool-admin-vue/tree/vue3-ts-vite\">📌 vue3.x + element-plus + ts + vite</a></p>\n</li>\n<li>\n<p><a href=\"https://gitee.com/cool-team-official/cool-admin-vue\">🌐 码云仓库地址</a></p>\n</li>\n</ul>\n<h2>演示</h2>\n<p><a href=\"https://show.cool-admin.com\">https://show.cool-admin.com</a></p>\n<ul>\n<li>账户：admin</li>\n<li>密码：123456</li>\n</ul>\n<p>官网：<a href=\"https://cool-js.com\">https://cool-js.com</a></p>\n</div>",
		"title": "node+vue3+vite+ts开源免费的后台管理系统",
		"last_reply_at": "2022-04-15T01:26:24.708Z",
		"good": false,
		"top": false,
		"reply_count": 10,
		"visit_count": 8439,
		"create_at": "2021-05-08T01:59:31.198Z",
		"author": {
			"loginname": "cool-team-official",
			"avatar_url": "https://avatars.githubusercontent.com/u/62868950?v=4&s=120"
		}
	}, {
		"id": "623476d6d9954e14ca7f8810",
		"author_id": "5b4d997faef62f1b0f9e03be",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p>年后遇到了两个服务的内存溢出问题，经过排查后得到了解决，因为NodeJS内存、cpu性能问题相关的用例比较少，所以事后做了下整理。</p>\n<h1>案例1</h1>\n<p>观察某个服务达到了 NodeJS 的内存上限（1.4G），然后抓取了内存快照，上传到了 easyMonitor 平台进行诊断。\n<img src=\"//static.cnodejs.org/Fpo-0CDtvM-38-PmELTarAErYInn\" alt=\"image.png\">\n通过内存快照分析工具，我们可以清晰地看到内存泄漏的主要原因是存在1273个TCP对象没有被释放。接着我们来看看具体是哪里导致了 TCP 对象的泄漏。\n<img src=\"//static.cnodejs.org/Fnki3xnnm_OQMRexvswXD5q5IY6C\" alt=\"image.png\">\n根据第一个 TCP 对象的地址 <a href=\"/user/4437\">@4437</a> 进行搜索。搜索出来的结果简单点来说：Edge 视图展示了这个对象拥有的数据结构；Retainer 视图展示了这个对象被哪些对象引用。我们排查问题的思路就是一级级向上寻找泄漏的对象被哪些对象引用，直到找到我们眼熟的对象来确定是哪一段代码导致的。\n熟悉 nodeJS 的同学应该知道 TCP 对象是被 NodeJS 的 Socket 持有的。所以，直接看下 Retainer 视图里 Socket<a href=\"/user/328785\">@328785</a> 的结构与引用。\n<img src=\"//static.cnodejs.org/FvqqcKreMw2L_qD0QQ6QgFUguZDX\" alt=\"image.png\">\n在 Retainer 视图里显示  SMTPConnection._socket 指向了我们搜索的socket地址，而 SMTPConnection 很明显是跟邮件相关的连接，我们这里问题范围缩小到了使用的 nodemailer 这个包上。\n<img src=\"//static.cnodejs.org/Fj-2gz7CfAF8duFbPDNXhuJ3dnEi\" alt=\"image.png\">\n接着继续分析 SMTPConnection<a href=\"/user/328773\">@328773</a> 被上下文 Context<a href=\"/user/328799\">@328799</a> 持有，查看 Context<a href=\"/user/328799\">@328799</a>。\n<img src=\"//static.cnodejs.org/FkZo87OoiHH9VJ6zYDX9iMuBW1y9\" alt=\"image.png\">\n从上图中我们能看到，这个上下文对象中包含 connection、sendMessage、socketOptions、returned、connection 这些结构，经过对 nodeMailer 源码的研究，我们能够通过这个上下文对象定位到  smtp-transport.js/SMTPTransport.prototype.send。下图中 this.getSocket 函数的 callback 持有的上下文（蓝框圈起来的部分）对应上图中的 system/Context 结构。 var connection = new SMTPConnection(options);  新建的连接没有被释放。\n<img src=\"//static.cnodejs.org/FqJyrdAOu1oiW1MNytr7wRqKW2ja\" alt=\"image.png\"></p>\n<h1>案例2</h1>\n<p>另外一个服务也出现了明显的内存异常，同样抓取了内存快照。\n<img src=\"//static.cnodejs.org/FvYl0x12oIpz6G-nVoMS_SMlH-9E\" alt=\"image.png\">\n通过工具分析，可以明显看到是因为 TLSSocket 没有释放导致了内存泄漏。查询第一个 TLSSocket 的地址 <a href=\"/user/4531505\">@4531505</a>：\n<img src=\"//static.cnodejs.org/FkQ_LkiRCVZVNSigpNilCmSMYl1j\" alt=\"image.png\">\n发现又指向了 SMTPConnection，由于在排查案例1的时候已经研究过 nodeMailer 包了，所以知道这里的 TLSSocket 是邮箱服务在 connect 的时候创建的 TLSSocket。于是接着查询 SMTPConnection<a href=\"/user/4531545\">@4531545</a>\n<img src=\"//static.cnodejs.org/FrC6zn12zXbVDbKcy-AuvfjsLcdW\" alt=\"image.png\">\n看到返回的535报错，发现原来是业务代码的重试机制导致一直在创建链接，但是链接又无法释放导致了内存升高。</p>\n<h1>为什么连接无法释放？</h1>\n<p>通过看 nodemailer 的代码，可以发现无论是 socket 发送邮件成功后还是 tlsSocket 报错最终都会调用 SMTPConnection.close 函数，并调用 socket.end() / tlsSocket.end()。\n问题出在了我们用的 nodemailer 包版本用的是 2.7.2 版本，后面一直没有升级，支持的 NodeJs 版本也比较低，然而高低版本的 socket.end() 实现逻辑不同。</p>\n<h2>NodeJS<a href=\"/user/9\">@9</a> 之前的版本</h2>\n<p>Node<a href=\"/user/9\">@9</a>（包括9）之前的版本在调用 socket.end 后会同步调用  TCP.close() 直接销毁连接。</p>\n<pre class=\"prettyprint language-js\"><code>Socket.prototype.end = function(data, encoding) {\n &#x2F;&#x2F; 调用双工流（可写流）的 end 函数会触发 finish 事件。\n  stream.Duplex.prototype.end.call(this, data, encoding);\n  this.writable = false;\n  &#x2F;&#x2F; just in case we&#x27;re waiting for an EOF.\n  if (this.readable &amp;&amp; !this._readableState.endEmitted)\n    this.read(0);\n  else\n    maybeDestroy(this);\n};\n\nfunction maybeDestroy(socket) {\n  if (!socket.readable &amp;&amp;\n      !socket.writable &amp;&amp;\n      !socket.destroyed &amp;&amp;\n      !socket.connecting &amp;&amp;\n      !socket._writableState.length) {\n    &#x2F;&#x2F; 这里调用的也是可写流的 destroy 函数\n    socket.destroy();\n  }\n}\n\n&#x2F;&#x2F; 可写流 destroy 函数\nfunction destroy(err, cb) {\n   &#x2F;&#x2F; 省略其余代码\n   &#x2F;&#x2F; destroy 函数会调用 socket._destroy。\n  this._destroy(err || null, (err) =&gt; {\n    if (!cb &amp;&amp; err) {\n      process.nextTick(emitErrorNT, this, err);\n      if (this._writableState) {\n        this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nSocket.prototype._destroy = function(exception, cb) {\n  this.connecting = false;\n  this.readable = this.writable = false;\n  if (this._handle) {\n    this[BYTES_READ] = this._handle.bytesRead;\n\n    &#x2F;&#x2F; this._handle = TCP()， 调用 TCP close 函数来关闭连接。\n    this._handle.close(() =&gt; {\n      debug(&#x27;emit close&#x27;);\n      this.emit(&#x27;close&#x27;, isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n  }\n\n  if (this._server) {\n    COUNTER_NET_SERVER_CONNECTION_CLOSE(this);\n    debug(&#x27;has server&#x27;);\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n</code></pre><h2>NodeJS<a href=\"/user/12\">@12</a></h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; socket 实现了Duplex，end 函数直接调用了 writableStream.end\nSocket.prototype.end = function(data, encoding, callback) {\n  stream.Duplex.prototype.end.call(this, data, encoding, callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n&#x2F;&#x2F; _stream_writable.js\n&#x2F;&#x2F; writableStream.end 最终会调用如下函数\nfunction finishMaybe(stream, state) {\n  const need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit(&#x27;finish&#x27;);\n\n      &#x2F;&#x2F; 这里的 state 存放可读流的状态变量\n      &#x2F;&#x2F; @node10 新增：autoDestroy 标志流是否在调用 end（）后自动调用自身的 destroy，在 v12 版本默认是 false。v14 版本开始默认为 true。\n      &#x2F;&#x2F; 所以当我们调用 socket.end（）的时候，不会立刻销毁自己，仅仅会触发 finish 事件。\n      if (state.autoDestroy) {\n        const rState = stream._readableState;\n        if (!rState || (rState.autoDestroy &amp;&amp; rState.endEmitted)) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\n\n&#x2F;&#x2F; 那么 socket 什么时候会被销毁呢？\n&#x2F;&#x2F; socket 构造函数\nfunction Socket(options) {\n     &#x2F;&#x2F; 忽略\n     &#x2F;&#x2F; 注册了 end 事件，触发的时候这个函数会调用自己的 destroy。\n     this.on(&#x27;end&#x27;, onReadableStreamEnd);\n}\n\nfunction onReadableStreamEnd() {\n  &#x2F;&#x2F; 省略\n  if (!this.destroyed &amp;&amp; !this.writable &amp;&amp; !this.writableLength)\n    &#x2F;&#x2F; 同样会调用可写流的 destroy 然后调用 socket._destory（）\n    this.destroy();\n}\n\n&#x2F;&#x2F; Socket 的 end 事件是可读流 read（）的时候触发的。\n&#x2F;&#x2F; n 参数指定要读取的特定字节数，如果不传，每次返回内部buffer中的全部数据。\nReadable.prototype.read = function(n){\n  const state = this._readableState;\n\n  &#x2F;&#x2F; 计算可以从缓冲区中读取多少数据。\n  n = howMuchToRead(n, state);\n\n  &#x2F;&#x2F; 本次可以读取的字节数为0\n  &#x2F;&#x2F; 流内部缓冲区buffer中的字节数为0\n  &#x2F;&#x2F; 可读流的 ended 状态为 true\n  if (n === 0 &amp;&amp; state.ended) {\n    if (state.length === 0)\n      &#x2F;&#x2F; 结束自己\n      endReadable(this);\n    return null;\n  }\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n  debug(&#x27;endReadable&#x27;, state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug(&#x27;endReadableNT&#x27;, state.endEmitted, state.length);\n  if (!state.endEmitted &amp;&amp; state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    &#x2F;&#x2F; 触发传入 stream（socket）的 end 事件。\n    stream.emit(&#x27;end&#x27;);\n\n    &#x2F;&#x2F;这里和可写流一样也有个 autoDestroy 参数，同样是默认 false。\n    if (state.autoDestroy) {\n      &#x2F;&#x2F; In case of duplex streams we need a way to detect\n      &#x2F;&#x2F; if the writable side is ready for autoDestroy as well\n      const wState = stream._writableState;\n      if (!wState || (wState.autoDestroy &amp;&amp; wState.finished)) {\n        stream.destroy();\n      }\n    }\n  }\n}\n</code></pre><p>由于我们的 nodemailer 版本较老，对应支持的 NodeJS 版本也比较旧，nodemailer 会移除 socket 对 end 事件的监听，导致在 node<a href=\"/user/12\">@12</a> 版本下，无法触发 end 事件，也就无法销毁 connection。\n最后升级了 nodemailer 包，问题解决。</p>\n</div>",
		"title": "nodemailer引发的内存泄漏问题排查小记",
		"last_reply_at": "2022-04-14T12:30:41.365Z",
		"good": false,
		"top": false,
		"reply_count": 7,
		"visit_count": 3415,
		"create_at": "2022-03-18T12:11:02.682Z",
		"author": {
			"loginname": "guojingkang",
			"avatar_url": "https://avatars.githubusercontent.com/u/39728127?v=4&s=120"
		}
	}, {
		"id": "6220450765073a72a232ee6e",
		"author_id": "5d44f5954f472f7fee15236f",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fs2LkN2Draenb0j475coQJ-RuN92\" alt=\"partner1.png\"></p>\n<h3><a href=\"https://wuyuan.io/activity/partner\">马上申请</a></h3>\n<h3>2021年，</h3>\n<p>我国人均 GDP 已经达到 1.2 万美元，北京、上海、江苏、广东等发达板块人均 GDP 超过 2 万美元，发达板块人口数量达到1.5亿。如果按照购买力平价计算，全国人均 GDP 则达到 2 万美元，发达板块人均 GDP 更是超过 3 万美元。在人均 GDP 水平不断提高的过程中，人工成本也会不断提高。<strong>高质量发展，高效率生产</strong>将是整个社会产业升级的持续主要诉求。</p>\n<h3>信息化、数字化是社会发展的不可逆的趋势。</h3>\n<p><strong><a href=\"http://www.gov.cn/gongbao/content/2022/content_5671108.htm\">《国务院关于印发“十四五”数字经济发展规划的通知（国务院公报2022年第3号）》</a></strong> 指出，数字经济是继农业经济、工业经济之后的主要经济形态。到2025年，软件和信息技术服务业产值将达到14万亿元。<strong>过去 20 年</strong>，我国 <strong>互联网 toC 领域</strong> 在实现信息化、数字化上走在了世界和时代的最前沿，然而在面向企业的信息化服务应用领域，似乎还在停滞在十年前甚至二十年前的状态。在过去几十年中，大量 <strong>国企事业单位</strong> 有条件在不考虑成本的情况下，通过实施大量项目，带动一方就业和提升政绩，而对于信息化项目本身的科学必要性，缺乏成效验证。系统应用建设虽多，大部分处于无人使用无人管理的状态，数据无法打通，流程无法形成闭环是常态，更无法幻想使用大数据分析、智能化决策等高附加值产品；而 <strong>广大中小企业</strong> 因为成本因素，更是依旧停留在纸质化流程办公阶段，稍有信息化意识的企业，也仅是在大量使用 Excel 或类 Excel 软件。即便像 <strong>华为</strong> 这样的超大型企业，任正非也不止一次提到企业内部 ID 不统一，访问每个不同的系统都要单独登录的困扰。而 <strong>小米</strong> 饥饿营销背后真实的原因却是核心的手机 BOM 管理和供应链管理依然使用大量 Excel 通过人工汇总校对导致产能无法跟上。</p>\n<p>在市场化竞争充分开放的环境下，如果信息化建设成本远超收益，那么企业当然宁愿使用成本更低的人工来解决。我们相信，<strong>帮助广大企业真正科学有效地实现信息化、数字化，是一项大有可为的事业</strong> 。无远希望与诸位合伙人一起，为广大开发者赋能，将平台基础能力输出到更广泛的，真正需要信息化的地方，让企业更早、更快、更高品质、更低成本地享数字化的便利，为推进整个社会的产业升级做出贡献！</p>\n<p><img src=\"//static.cnodejs.org/Fgbk_sITuL0zxh2GOF04efd7_rPj\" alt=\"zuowei.jpeg\"></p>\n</div>",
		"title": "真正的复利高手，一定是长期主义者",
		"last_reply_at": "2022-04-13T13:00:57.860Z",
		"good": false,
		"top": false,
		"reply_count": 2,
		"visit_count": 7210,
		"create_at": "2022-03-03T04:33:11.784Z",
		"author": {
			"loginname": "dafanzhi",
			"avatar_url": "https://avatars.githubusercontent.com/u/53632540?v=4&s=120"
		}
	}, {
		"id": "6251641079f90d0fa7a0c7a5",
		"author_id": "5a051be2ee9b35da75a869f7",
		"tab": "share",
		"content": "<div class=\"markdown-text\"><p><img src=\"https://user-images.githubusercontent.com/23253540/162456565-86fe05ac-757d-46fd-aad3-e344811c62cb.png\" alt=\"image\"></p>\n<blockquote>\n<p>最近更文较少, 主要忙于各大团购群买菜 + 做饭 + 做核酸 + 远程办公。从 3月30号 到今天小区已经封了 11 天, 上海疫情又创了新高 1015 + 22609 例。只希望这波疫情赶紧结束, 不要再出负面新闻了 😓 。图片来自封控前的一次囤货外出。</p>\n</blockquote>\n<h2>背景</h2>\n<p>近期在对 SSR 项目进行 <strong><em>CDN和域名灾备</em></strong> 的改造, 同学 a 负责的 Next.js 项目改造测试时发现 CDN 没有预期内的动态切换。这个项目一直有历史包袱, 我想着不会线上 Node 一直是挂的吧,  难道长久以来都是 Nginx 返回的静态兜底页面?</p>\n<h2>问题排查</h2>\n<p>本地启动了该项目, 发现无论是服务端渲染请求还是健康检查 Node 服务都没有异常。得出 Node 大概率是一直正常运行的, 那么会是其他什么原因导致的一直返回的是静态资源而非实时的 SSR 直出了?</p>\n<p>真正的原因是当你的 src/pages/_app.tsx 文件中导出的 App 组件或者某个 Page 组件没有定义 getInitialProps 或者 getServerSideProps 这个静态方法, 意味着你其实是不需要在服务端进行注水(比如拉取用户的某个真实数据接口, 然后实时渲染直出)。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; demo\n\nfunction Page({ stars }) {\n  return &lt;div&gt;Next stars: {stars}&lt;&#x2F;div&gt;\n}\n\nPage.getInitialProps = async (ctx) =&gt; {\n  const res = await fetch(&#x27;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;vercel&#x2F;next.js&#x27;)\n  const json = await res.json()\n  return { stars: json.stargazers_count }\n}\n\nexport default Page\n</code></pre><p>此时 Next.js 会在打包构建阶段预渲染一个静态 html, 到项目发布成功 Node 服务开始运行的时候直接返回该静态 html 即可。因为不需要注水, html 的最终形态构建时就能决定下来了, 没必要服务端再实时渲染, 既能减少 CPU 消耗又能难缩短 rt。</p>\n<p>后面查阅了一下文档, Next.js 称这个优化点为 <a href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\">Automatic Static Optimization</a>。</p>\n<h2>代码实现</h2>\n<h3>构建时</h3>\n<p>可以看到 isStatic 的值为 true 的条件, 即导出的 App 组件没有定义 getStaticProps、 getInitialProps、getServerSideProps 任意一个静态方法</p>\n<pre class=\"prettyprint language-typescript\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;build&#x2F;utils.ts\n\nexport async function isPageStatic(\n  &#x2F;&#x2F; ...\n}&gt; {\n  return isPageStaticSpan.traceAsyncFn(async () =&gt; {\n    try {\n\n      const mod = await loadComponents(distDir, page, serverless)\n      const Comp = mod.Component\n\n      const hasFlightData = !!(mod as any).__next_rsc__\n      const hasGetInitialProps = !!(Comp as any).getInitialProps\n      const hasStaticProps = !!mod.getStaticProps\n      const hasStaticPaths = !!mod.getStaticPaths\n      const hasServerProps = !!mod.getServerSideProps\n    \n      &#x2F;&#x2F; ...\n        \n      return {\n        isStatic:\n          !hasStaticProps &amp;&amp;\n          !hasGetInitialProps &amp;&amp;\n          !hasServerProps &amp;&amp;\n          !hasFlightData,\n        isHybridAmp: config.amp === &#x27;hybrid&#x27;,\n        &#x2F;&#x2F; ...\n      }\n    } catch (err) {\n      if (isError(err) &amp;&amp; err.code === &#x27;MODULE_NOT_FOUND&#x27;) return {}\n      throw err\n    }\n  })\n}\n</code></pre><p>对于 isStatic 的值为 true 的页面 (staticPages) 和定义了 getStaticProps(ssgPages) 静态方法的页面就会通过 exportApp 方法进行预渲染生成静态 html。</p>\n<ul>\n<li>exportApp 的预渲染是调用的 ReactDOMServer.renderToString, 并非是借助的 puppeteer</li>\n<li>next export 命令也是调用的 exportApp 方法</li>\n</ul>\n<pre class=\"prettyprint language-typescript\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;build&#x2F;index.ts\n\nexport default async function build(\n  dir: string,\n  conf = null,\n  reactProductionProfiling = false,\n  debugOutput = false,\n  runLint = true\n): Promise&lt;void&gt; {\n\t&#x2F;&#x2F; ...\n\n    const combinedPages = [...staticPages, ...ssgPages]\n\n    if (combinedPages.length &gt; 0 || useStatic404 || useDefaultStatic500) {\n      &#x2F;&#x2F; ...\n        const exportApp: typeof import(&#x27;..&#x2F;export&#x27;).default =\n          require(&#x27;..&#x2F;export&#x27;).default\n        const exportOptions = {\n          &#x2F;&#x2F; ...\n        }\n        const exportConfig: any = {\n         &#x2F;&#x2F; ...\n        }\n\n        await exportApp(dir, exportOptions, nextBuildSpan, exportConfig)\n\n        &#x2F;&#x2F; ...\n}\n</code></pre><p>构建阶段生成好静态的 html 文件, 服务运行时直接返回即可</p>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/162478644-c40212d6-be39-4e67-9775-035d5d685985.png\" alt=\"image\"></p>\n<p>对于定义了 getInitialProps 或者 getServerSideProps 静态方法的组件构建阶段则只会生成服务端运行时需要的 js 文件\n<img src=\"https://user-images.githubusercontent.com/23253540/162479210-273c9fa2-6930-4810-bfee-85c93547c3ce.png\" alt=\"image\"></p>\n<h3>运行时</h3>\n<p>如果发现所需组件是一个 html 文件, requirePage 方法就会返回该 html 的字符串。如果是一个 js 文件则正常返回该模块的 module.exports, 然后服务端渲染该组件生成 html 字符串</p>\n<pre class=\"prettyprint language-typescript\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;server&#x2F;load-components.ts\n\nexport async function loadComponents(\n  distDir: string,\n  pathname: string,\n  serverless: boolean,\n  serverComponents?: boolean\n): Promise&lt;LoadComponentsReturnType&gt; {\n  if (serverless) {\n    const ComponentMod = await requirePage(pathname, distDir, serverless)\n    if (typeof ComponentMod === &#x27;string&#x27;) {\n      return {\n        Component: ComponentMod as any,\n        pageConfig: {},\n        ComponentMod,\n      } as LoadComponentsReturnType\n    }\n\n    let {\n      default: Component,\n      getStaticProps,\n      getStaticPaths,\n      getServerSideProps,\n    } = ComponentMod\n\n    Component = await Component\n    getStaticProps = await getStaticProps\n    getStaticPaths = await getStaticPaths\n    getServerSideProps = await getServerSideProps\n    const pageConfig = (await ComponentMod.config) || {}\n\n    return {\n      Component,\n      pageConfig,\n      getStaticProps,\n      getStaticPaths,\n      getServerSideProps,\n      ComponentMod,\n    } as LoadComponentsReturnType\n  }\n\n  &#x2F;&#x2F; ...\n}\n</code></pre><p>代码看到这里我们知道了</p>\n<ul>\n<li>getInitialProps 和 getServerSideProps 是服务端渲染时才会运行的用于注水的钩子函数, Next.js 推荐使用 getServerSideProps 函数</li>\n<li>getStaticProps 是构建时才会运行的用于注水的钩子函数</li>\n</ul>\n<h3>如何区分</h3>\n<p>通过下面的代码可以看见可以通过 Next.js 注入的 <strong>NEXT_DATA</strong> 的 gsp, gssp, gip 等值即可以快速判断当前页面是何种方式进行的渲染方式</p>\n<pre class=\"prettyprint language-typescript\"><code>&#x2F;&#x2F; packages&#x2F;next&#x2F;server&#x2F;render.tsx\n\nexport async function renderToHTML(\n  req: IncomingMessage,\n  res: ServerResponse,\n  pathname: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts\n): Promise&lt;RenderResult | null&gt; {\n  &#x2F;&#x2F; ...\n  \n  const htmlProps: HtmlProps = {\n    __NEXT_DATA__: {\n      props, &#x2F;&#x2F; The result of getInitialProps\n      nextExport: nextExport === true ? true : undefined, &#x2F;&#x2F; If this is a page exported by &#96;next export&#96;\n      autoExport: isAutoExport === true ? true : undefined, &#x2F;&#x2F; If this is an auto exported page\n      gsp: !!getStaticProps ? true : undefined, &#x2F;&#x2F; whether the page is getStaticProps\n      gssp: !!getServerSideProps ? true : undefined, &#x2F;&#x2F; whether the page is getServerSideProps\n      rsc: isServerComponent ? true : undefined, &#x2F;&#x2F; whether the page is a server components page\n      customServer, &#x2F;&#x2F; whether the user is using a custom server\n      gip: hasPageGetInitialProps ? true : undefined, &#x2F;&#x2F; whether the page has getInitialProps\n      appGip: !defaultAppGetInitialProps ? true : undefined, &#x2F;&#x2F; whether the _app has getInitialProps\n      &#x2F;&#x2F; ...\n    },\n  }\n\n  &#x2F;&#x2F; ...\n\n  return new RenderResult(chainStreams(streams))\n}\n</code></pre><p>知道如何区分后回头看看该项目返回的 html 就可以快速知道该页面是没有定义 getStaticProps、getInitialProps、getServerSideProps 任意一个静态方法的即 isStatic 为 true 的静态页面\n<img src=\"https://user-images.githubusercontent.com/23253540/162563683-6ff27dde-b153-480a-87fe-6ebd21ae9469.png\" alt=\"image\"></p>\n<h2>小结</h2>\n<p>由于没有定义 getInitialProps、getServerSideProps 任意一个静态方法故 Node 实时的获取 CDN 配置信息以及渲染的逻辑没有运行, 该页面的请求都是 Node 直接返回的静态 html。</p>\n<p>原文链接: <a href=\"https://github.com/xiaoxiaojx/blog/issues/34\">https://github.com/xiaoxiaojx/blog/issues/34</a></p>\n</div>",
		"title": "Next.js 未能实时渲染问题排查",
		"last_reply_at": "2022-04-11T05:50:35.195Z",
		"good": false,
		"top": false,
		"reply_count": 4,
		"visit_count": 1709,
		"create_at": "2022-04-09T10:46:40.395Z",
		"author": {
			"loginname": "xiaoxiaojx",
			"avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
		}
	}]
}